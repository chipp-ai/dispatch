name: Auto-Investigate Error

on:
  workflow_dispatch:
    inputs:
      issue_id:
        description: "Dispatch issue ID"
        required: true
        type: string
      issue_identifier:
        description: "Human-readable identifier (e.g. DISPATCH-456)"
        required: true
        type: string
      title:
        description: "Issue title"
        required: true
        type: string
      description:
        description: "Full error context (markdown)"
        required: true
        type: string
      source:
        description: "Error source module"
        required: true
        type: string
      feature:
        description: "Error feature area"
        required: true
        type: string
      error_message:
        description: "The actual error message from the exception"
        required: false
        type: string
      stack_trace:
        description: "Stack trace from the exception"
        required: false
        type: string
      error_fingerprint:
        description: "Error fingerprint for dedup reference"
        required: false
        type: string
      additional_context:
        description: "Additional instructions from human retry (optional)"
        required: false
        type: string
      callback_url:
        description: "Override API callback URL (for local dev tunnels)"
        required: false
        type: string
      ref:
        description: "Git ref to checkout (branch, tag, or SHA). Defaults to the workflow dispatch ref."
        required: false
        type: string

# Only one investigation per issue at a time
concurrency:
  group: auto-investigate-${{ inputs.issue_identifier }}
  cancel-in-progress: false

jobs:
  investigate:
    name: Investigate ${{ inputs.issue_identifier }}
    runs-on: ubuntu-latest
    timeout-minutes: 30

    permissions:
      contents: write
      pull-requests: write

    # All user-provided inputs go through env vars to prevent command injection.
    # See: https://github.blog/security/vulnerability-research/how-to-catch-github-actions-workflow-injections-before-attackers-do/
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      # callback_url input overrides the production API URL (for local dev tunnels)
      DISPATCH_API_URL: ${{ inputs.callback_url || secrets.DISPATCH_API_URL }}
      DISPATCH_API_KEY: ${{ secrets.DISPATCH_API_KEY }}
      DENO_NO_PACKAGE_JSON: "1"
      INPUT_ISSUE_ID: ${{ inputs.issue_id }}
      INPUT_ISSUE_IDENTIFIER: ${{ inputs.issue_identifier }}
      INPUT_TITLE: ${{ inputs.title }}
      INPUT_DESCRIPTION: ${{ inputs.description }}
      INPUT_SOURCE: ${{ inputs.source }}
      INPUT_FEATURE: ${{ inputs.feature }}
      INPUT_ERROR_FINGERPRINT: ${{ inputs.error_fingerprint }}
      INPUT_ERROR_MESSAGE: ${{ inputs.error_message }}
      INPUT_STACK_TRACE: ${{ inputs.stack_trace }}
      INPUT_ADDITIONAL_CONTEXT: ${{ inputs.additional_context }}
      GITHUB_RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref || github.ref_name }}
          fetch-depth: 0

      - name: Setup Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Sanitize branch name
        id: branch
        run: |
          # Lowercase, replace non-alphanumeric (except hyphens) with hyphens, collapse runs
          SAFE_ID=$(echo "$INPUT_ISSUE_IDENTIFIER" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/-\+/-/g' | sed 's/^-//;s/-$//')
          echo "name=auto-fix/${SAFE_ID}" >> "$GITHUB_OUTPUT"
          echo "Branch name: auto-fix/${SAFE_ID}"

      - name: Notify Dispatch - In Progress
        if: env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        run: |
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          # Build JSON payload safely with jq
          PAYLOAD=$(jq -n \
            --arg status "in_progress" \
            --arg spawn_status "running" \
            --arg spawn_run_id "$GITHUB_RUN_ID" \
            --arg spawn_started_at "$TIMESTAMP" \
            '{status: $status, spawn_status: $spawn_status, spawn_run_id: $spawn_run_id, spawn_started_at: $spawn_started_at}')

          curl -sf -X PATCH "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" || echo "Warning: Failed to notify Dispatch (non-fatal)"

      - name: Create Run Record
        id: create-run
        if: env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        run: |
          RUN_PAYLOAD=$(jq -n \
            --arg workflow_type "error_fix" \
            --arg github_run_id "$GITHUB_RUN_ID" \
            --arg github_run_url "${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}" \
            '{workflow_type: $workflow_type, github_run_id: $github_run_id, github_run_url: $github_run_url}')

          RESPONSE=$(curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/runs" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$RUN_PAYLOAD" 2>/dev/null) || true

          AGENT_RUN_ID=$(echo "$RESPONSE" | jq -r '.id // empty' 2>/dev/null)
          echo "agent_run_id=${AGENT_RUN_ID}" >> "$GITHUB_OUTPUT"
          echo "Created run record: ${AGENT_RUN_ID}"

      - name: Run Investigation
        id: investigate
        env:
          BRANCH_NAME: ${{ steps.branch.outputs.name }}
        run: |
          mkdir -p .scratch

          # Build the prompt. Leading spaces from YAML indentation are stripped by sed.
          cat > .scratch/investigation-prompt.md <<PROMPT_BOUNDARY
          You are autonomously investigating a production error for this project.

          Issue: ${INPUT_ISSUE_IDENTIFIER} - ${INPUT_TITLE}

          Error Context:
          ${INPUT_DESCRIPTION}

          Source: ${INPUT_SOURCE}
          Feature: ${INPUT_FEATURE}
          Error Fingerprint: ${INPUT_ERROR_FINGERPRINT}
          $([ -n "${INPUT_ERROR_MESSAGE}" ] && echo "
          Error Message: ${INPUT_ERROR_MESSAGE}
          ")
          $([ -n "${INPUT_STACK_TRACE}" ] && echo "
          Stack Trace:
          ${INPUT_STACK_TRACE}
          ")
          $([ -n "${INPUT_ADDITIONAL_CONTEXT}" ] && echo "
          ADDITIONAL CONTEXT FROM HUMAN:
          ${INPUT_ADDITIONAL_CONTEXT}
          ")
          LOKI QUERY REFERENCE (include relevant queries in your investigation report so humans can drill deeper):
          - Recent errors: {app="chipp-deno", level="error"} | json | source="${INPUT_SOURCE}" | feature="${INPUT_FEATURE}"
          - Affected users: {app="chipp-deno", level="error"} | json | source="${INPUT_SOURCE}" | feature="${INPUT_FEATURE}" | userId!=""
          - User activity around error: {app="chipp-deno"} | json | source="analytics" | userId="<affected-user-id>"
          - Error frequency: sum(count_over_time({app="chipp-deno", level="error"} | json | source="${INPUT_SOURCE}" | feature="${INPUT_FEATURE}" [5m]))

          Instructions:
          1. Read CLAUDE.md first to understand the codebase
          2. Run a thorough autonomous investigation following the /autonomous-investigation methodology
          3. Identify the root cause with specific file paths and line numbers
          4. Write your investigation report to .scratch/investigation-report.md with these sections:
             - Root Cause: What went wrong and where (file paths + line numbers)
             - User Impact: Who was affected (user IDs, org IDs, how many users, what they experienced)
             - Fix Description: What you changed and why (if a fix was applied)
             - Verification: How you confirmed the fix works
             The report becomes part of the PR description and must be clear enough for a human
             reviewer to understand the bug, the impact, and the fix without reading the code diff.
          5. If you can identify a fix with HIGH confidence:
             a. Create a new branch from staging: git checkout -b ${BRANCH_NAME}
             b. Implement the fix
             c. Run 'deno check main.ts' to verify type safety
             d. Stage and commit: git add -A && git commit -m "fix(${INPUT_SOURCE}): description [${INPUT_ISSUE_IDENTIFIER}]"
          6. If you cannot identify a confident fix, that is fine - just write the investigation report
          7. Do NOT attempt fixes you are not confident about
          8. Do NOT push any branches - just prepare the commit locally

          GIT WORKFLOW (CRITICAL - READ THIS):
          If you change ANY file, you MUST create a branch and commit before exiting.
          The workflow CANNOT create a PR from uncommitted changes. If you edit files
          but do not commit, your work is lost. The sequence is ALWAYS:
            git checkout -b ${BRANCH_NAME}
            # ... make changes ...
            git add -A
            git commit -m "fix(${INPUT_SOURCE}): description [${INPUT_ISSUE_IDENTIFIER}]"
          Then set pr_needed=true in run-result.json. No commit = no PR = wasted work.

          ENVIRONMENT VARIABLES:
          If you need an environment variable, FIRST read .env and .env.example to check what is
          already configured. Only report a missing env var as a blocker AFTER checking both files.

          PRE-EXISTING ISSUES:
          If you encounter a pre-existing bug, wrong env var name, broken import, or misconfiguration
          during your investigation, include it in your report AND fix it if you're committing a fix.

          MANDATORY - RUN RESULT DECLARATION:
          Before exiting, you MUST write .scratch/run-result.json with:
          {
            "outcome": "completed|no_changes_needed|blocked|needs_human_decision|investigation_complete|failed",
            "summary": "1-2 sentence explanation of your decision",
            "changes_made": true/false,
            "files_changed": ["list", "of", "paths"],
            "pr_needed": true/false
          }

          - "completed": You identified and committed a fix. Set pr_needed=true, changes_made=true.
          - "no_changes_needed": The error is already fixed or cannot reproduce. Set pr_needed=false.
          - "investigation_complete": You wrote findings but no confident fix. Set pr_needed=false.
          - "blocked": Missing info needed from a human. Set pr_needed=false.
          - "needs_human_decision": Multiple valid approaches, human should pick. Set pr_needed=false.
          - "failed": Could not investigate. Set pr_needed=false.
          PROMPT_BOUNDARY
          sed -i 's/^          //' .scratch/investigation-prompt.md

          # Create stream filter for human-readable output
          cat > .scratch/stream-filter.py << 'PYEOF'
          import sys, json
          for line in sys.stdin:
              line = line.strip()
              if not line: continue
              try:
                  event = json.loads(line)
                  t = event.get("type", "")
                  if t == "assistant":
                      for c in event.get("message", {}).get("content", []):
                          if c.get("type") == "text" and c.get("text"):
                              print(c["text"], flush=True)
                          elif c.get("type") == "tool_use":
                              name = c.get("name", "unknown")
                              inp = c.get("input", {})
                              parts = [f"{k}={str(v)[:80]}" for k, v in list(inp.items())[:3]]
                              print(f"[TOOL] {name}({', '.join(parts)})", flush=True)
                  elif t == "tool_result":
                      content = event.get("content", "")
                      if isinstance(content, list):
                          content = " ".join(c.get("text", "") for c in content if isinstance(c, dict))
                      preview = str(content)[:200] + ("..." if len(str(content)) > 200 else "")
                      print(f"[RESULT] {preview}", flush=True)
                  elif t == "result":
                      print(f"\n[COMPLETED] Cost: ${event.get('total_cost_usd', 0):.2f}, Turns: {event.get('num_turns', 0)}", flush=True)
              except (json.JSONDecodeError, KeyError):
                  print(line, flush=True)
          PYEOF

          # Claude CLI buffers ALL output when stdout is not a TTY.
          # Use `script` to create a pseudo-TTY, forcing line-buffered output.
          cat > .scratch/run-claude.sh << 'RUNEOF'
          #!/bin/bash
          PROMPT=$(cat .scratch/investigation-prompt.md)
          exec claude --print --model claude-opus-4-6 --verbose --output-format stream-json --dangerously-skip-permissions "$PROMPT"
          RUNEOF
          chmod +x .scratch/run-claude.sh

          script -qef .scratch/claude-raw.log -c "bash .scratch/run-claude.sh" > /dev/null 2>&1 &
          CLAUDE_PID=$!
          echo "Claude started (PID: $CLAUDE_PID)"

          PREV_LINES=0
          while kill -0 $CLAUDE_PID 2>/dev/null; do
            sleep 15
            [ -f .scratch/claude-raw.log ] || continue
            CURR_LINES=$(wc -l < .scratch/claude-raw.log)
            if [ "$CURR_LINES" -gt "$PREV_LINES" ]; then
              CHUNK=$(sed -n "$((PREV_LINES + 1)),${CURR_LINES}p" .scratch/claude-raw.log \
                | python3 -u .scratch/stream-filter.py)
              echo "$CHUNK"

              # Stream to Dispatch terminal viewer
              if [ -n "$CHUNK" ] && [ -n "$DISPATCH_API_URL" ] && [ -n "$DISPATCH_API_KEY" ]; then
                jq -n --arg content "$CHUNK" '{content: $content}' | \
                  curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/terminal" \
                    -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
                    -H "Content-Type: application/json" \
                    -d @- > /dev/null 2>&1 &
              fi

              PREV_LINES=$CURR_LINES
            else
              echo "[$(date -u +%H:%M:%S)] Claude working... ($CURR_LINES lines)"
            fi
          done
          wait $CLAUDE_PID
          CLAUDE_EXIT=$?
          echo "=== Claude exited with code $CLAUDE_EXIT ==="

          FINAL_LINES=$(wc -l < .scratch/claude-raw.log)
          if [ "$FINAL_LINES" -gt "$PREV_LINES" ]; then
            FINAL_CHUNK=$(sed -n "$((PREV_LINES + 1)),${FINAL_LINES}p" .scratch/claude-raw.log \
              | python3 -u .scratch/stream-filter.py)
            echo "$FINAL_CHUNK"
            if [ -n "$FINAL_CHUNK" ] && [ -n "$DISPATCH_API_URL" ] && [ -n "$DISPATCH_API_KEY" ]; then
              jq -n --arg content "$FINAL_CHUNK" '{content: $content}' | \
                curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/terminal" \
                  -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
                  -H "Content-Type: application/json" \
                  -d @- > /dev/null 2>&1 || true
            fi
          fi
          python3 -u .scratch/stream-filter.py < .scratch/claude-raw.log > .scratch/claude-output.log

          # Extract cost data from stream-json result event
          python3 -c "
          import json
          for line in open('.scratch/claude-raw.log'):
              line = line.strip()
              if not line: continue
              try:
                  event = json.loads(line)
                  if event.get('type') == 'result':
                      cost = event.get('total_cost_usd', 0)
                      turns = event.get('num_turns', 0)
                      model = event.get('model', 'unknown')
                      with open('.scratch/claude-cost.json', 'w') as f:
                          json.dump({'cost_usd': cost, 'num_turns': turns, 'model': model}, f)
                      print(f'Cost: \${cost:.4f}, Turns: {turns}, Model: {model}')
              except (json.JSONDecodeError, KeyError): pass
          " 2>/dev/null || echo "Warning: Could not extract cost data"

          exit $CLAUDE_EXIT

          # Ensure investigation report exists even if Claude didn't create one
          if [ ! -f .scratch/investigation-report.md ]; then
            {
              echo "# Investigation Report"
              echo ""
              echo "Claude Code did not produce a structured report. Raw output saved to claude-output.log."
              echo ""
              echo '```'
              tail -100 .scratch/claude-output.log
              echo '```'
            } > .scratch/investigation-report.md
          fi

      - name: Parse run result
        id: run-result
        if: always()
        run: |
          if [ ! -f .scratch/run-result.json ]; then
            echo "outcome=failed" >> "$GITHUB_OUTPUT"
            echo "Agent exited without declaring an outcome" > .scratch/outcome-summary.txt
            echo "pr_needed=false" >> "$GITHUB_OUTPUT"
            echo "changes_made=false" >> "$GITHUB_OUTPUT"
            echo "Run outcome: failed (no run-result.json)"
            exit 0
          fi

          OUTCOME=$(jq -r '.outcome // "failed"' .scratch/run-result.json)
          SUMMARY=$(jq -r '.summary // "No summary provided"' .scratch/run-result.json)
          PR_NEEDED=$(jq -r '.pr_needed // false' .scratch/run-result.json)
          CHANGES_MADE=$(jq -r '.changes_made // false' .scratch/run-result.json)

          case "$OUTCOME" in
            completed|no_changes_needed|blocked|needs_human_decision|investigation_complete|failed) ;;
            *) OUTCOME="failed"; SUMMARY="Invalid outcome: $OUTCOME" ;;
          esac

          echo "outcome=$OUTCOME" >> "$GITHUB_OUTPUT"
          echo "$SUMMARY" > .scratch/outcome-summary.txt
          echo "pr_needed=$PR_NEEDED" >> "$GITHUB_OUTPUT"
          echo "changes_made=$CHANGES_MADE" >> "$GITHUB_OUTPUT"

          echo "Run outcome: $OUTCOME"
          echo "Summary: $SUMMARY"

      - name: Check for fix
        id: check-fix
        env:
          BRANCH_NAME: ${{ steps.branch.outputs.name }}
          ISSUE_SOURCE: ${{ inputs.source }}
          ISSUE_TITLE: ${{ inputs.title }}
          ISSUE_ID: ${{ inputs.issue_identifier }}
        run: |
          # Check if Claude created a new branch with commits ahead of staging
          CURRENT_BRANCH=$(git branch --show-current)
          if [ "$CURRENT_BRANCH" != "staging" ] && git log --oneline staging..HEAD 2>/dev/null | grep -q .; then
            echo "fix_attempted=true" >> "$GITHUB_OUTPUT"
            echo "Fix was committed on branch: $CURRENT_BRANCH"
          elif git diff --quiet && git diff --cached --quiet; then
            echo "fix_attempted=false" >> "$GITHUB_OUTPUT"
            echo "No fix attempted - investigation report only"
          else
            # Agent made changes but forgot to create a branch and commit.
            # Salvage the work: create the branch, stage, and commit.
            echo "Agent left uncommitted changes -- auto-committing"
            git diff --stat

            if [ "$CURRENT_BRANCH" = "staging" ]; then
              git checkout -b "$BRANCH_NAME"
            fi

            git add -A
            # Exclude scratch files from the commit
            git reset -- .scratch/ 2>/dev/null || true
            if ! git diff --cached --quiet; then
              SUMMARY=""
              if [ -f .scratch/outcome-summary.txt ]; then
                SUMMARY=$(head -1 .scratch/outcome-summary.txt)
              fi
              git commit -m "fix($ISSUE_SOURCE): $ISSUE_TITLE [$ISSUE_ID]

$SUMMARY

Co-Authored-By: Claude Code <noreply@anthropic.com>"
              echo "fix_attempted=true" >> "$GITHUB_OUTPUT"
              echo "Auto-committed agent changes on branch: $(git branch --show-current)"
            else
              echo "fix_attempted=false" >> "$GITHUB_OUTPUT"
              echo "No meaningful changes to commit after excluding scratch files"
            fi
          fi

      - name: Push branch and create PR
        id: create-pr
        if: steps.run-result.outputs.pr_needed == 'true' || (steps.check-fix.outputs.fix_attempted == 'true' && steps.run-result.outputs.changes_made == 'true')
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          BRANCH_NAME=$(git branch --show-current)
          git push origin "HEAD:${BRANCH_NAME}"

          # Build PR body file (avoids shell escaping issues with large report content)
          DISPATCH_ISSUE_URL="${DISPATCH_API_URL}/issue/${INPUT_ISSUE_IDENTIFIER}"
          {
            echo "## Error Summary"
            echo ""
            echo "**Issue:** [${INPUT_ISSUE_IDENTIFIER}](${DISPATCH_ISSUE_URL}) -- ${INPUT_TITLE}"
            echo ""
            echo "### Error Details"
            echo ""
            echo "**Source:** \`${INPUT_SOURCE}\` | **Feature:** \`${INPUT_FEATURE}\`"
            echo ""
            if [ -n "${INPUT_ERROR_MESSAGE}" ]; then
              echo "**Error Message:**"
              echo "\`\`\`"
              echo "${INPUT_ERROR_MESSAGE}"
              echo "\`\`\`"
              echo ""
            fi
            if [ -n "${INPUT_STACK_TRACE}" ]; then
              echo "**Stack Trace:**"
              echo "\`\`\`"
              echo "${INPUT_STACK_TRACE}"
              echo "\`\`\`"
              echo ""
            fi
            echo "---"
            echo ""
            echo "## Investigation Report"
            echo ""
            cat .scratch/investigation-report.md
            echo ""
            echo "---"
            echo ""
            echo "Autonomously generated by Claude Code for ${INPUT_ISSUE_IDENTIFIER}"
            echo ""
            echo "- **Investigation**: [${INPUT_ISSUE_IDENTIFIER} on Dispatch](${DISPATCH_ISSUE_URL})"
            echo "- **Run**: [${GITHUB_RUN_ID}](${GITHUB_RUN_URL})"
            echo "- **Fingerprint**: \`${INPUT_ERROR_FINGERPRINT}\`"
          } > .scratch/pr-body.md

          PR_URL=$(gh pr create \
            --title "fix(${INPUT_SOURCE}): ${INPUT_TITLE} [${INPUT_ISSUE_IDENTIFIER}]" \
            --body-file .scratch/pr-body.md \
            --base staging \
            --head "${BRANCH_NAME}")

          echo "pr_url=${PR_URL}" >> "$GITHUB_OUTPUT"
          echo "Created PR: ${PR_URL}"

      - name: Post results to Dispatch
        if: always() && env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        env:
          PR_URL: ${{ steps.create-pr.outputs.pr_url }}
          FIX_ATTEMPTED: ${{ steps.check-fix.outputs.fix_attempted }}
          JOB_STATUS: ${{ job.status }}
          OUTCOME: ${{ steps.run-result.outputs.outcome }}
          AGENT_RUN_ID: ${{ steps.create-run.outputs.agent_run_id }}
        run: |
          # Determine spawn status based on job outcome
          if [ "$JOB_STATUS" = "success" ]; then
            SPAWN_STATUS="completed"
          else
            SPAWN_STATUS="failed"
          fi

          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          # Ensure report file exists for jq --rawfile
          if [ ! -f .scratch/investigation-report.md ]; then
            echo "No investigation report was generated." > .scratch/investigation-report.md
          fi

          # Read cost data if available
          COST_USD="0"
          NUM_TURNS="0"
          MODEL="unknown"
          if [ -f .scratch/claude-cost.json ]; then
            COST_USD=$(jq -r '.cost_usd // 0' .scratch/claude-cost.json)
            NUM_TURNS=$(jq -r '.num_turns // 0' .scratch/claude-cost.json)
            MODEL=$(jq -r '.model // "unknown"' .scratch/claude-cost.json)
          fi

          # Build activity JSON safely with jq (--rawfile handles large reports)
          ACTIVITY_PAYLOAD=$(jq -n \
            --arg type "investigation_complete" \
            --rawfile content .scratch/investigation-report.md \
            --arg pr_url "$PR_URL" \
            --arg fix_attempted "${FIX_ATTEMPTED:-false}" \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_url "$GITHUB_RUN_URL" \
            --arg source "$INPUT_SOURCE" \
            --arg feature "$INPUT_FEATURE" \
            --arg fingerprint "$INPUT_ERROR_FINGERPRINT" \
            --arg cost_usd "$COST_USD" \
            --arg num_turns "$NUM_TURNS" \
            --arg model "$MODEL" \
            --arg agent_run_id "$AGENT_RUN_ID" \
            '{
              type: $type,
              content: $content,
              metadata: {
                pr_url: $pr_url,
                fix_attempted: $fix_attempted,
                run_id: $run_id,
                run_url: $run_url,
                source: $source,
                feature: $feature,
                fingerprint: $fingerprint,
                cost_usd: $cost_usd,
                num_turns: $num_turns,
                model: $model,
                agent_run_id: $agent_run_id
              }
            }')

          curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/activity" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$ACTIVITY_PAYLOAD" || echo "Warning: Failed to post activity to Dispatch (non-fatal)"

          # Read outcome summary from file
          OUTCOME_SUMMARY=""
          if [ -f .scratch/outcome-summary.txt ]; then
            OUTCOME_SUMMARY=$(cat .scratch/outcome-summary.txt)
          fi

          # Update spawn status with cost data and outcome
          STATUS_PAYLOAD=$(jq -n \
            --arg spawn_status "$SPAWN_STATUS" \
            --arg spawn_completed_at "$TIMESTAMP" \
            --arg cost_usd "$COST_USD" \
            --arg num_turns "$NUM_TURNS" \
            --arg model "$MODEL" \
            --arg run_outcome "${OUTCOME:-failed}" \
            --arg outcome_summary "$OUTCOME_SUMMARY" \
            '{spawn_status: $spawn_status, spawn_completed_at: $spawn_completed_at, cost_usd: $cost_usd, num_turns: $num_turns, model: $model, run_outcome: $run_outcome, outcome_summary: $outcome_summary}')

          curl -sf -X PATCH "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$STATUS_PAYLOAD" || echo "Warning: Failed to update spawn status (non-fatal)"

          # Update agent run record with full results
          if [ -n "$AGENT_RUN_ID" ]; then
            # Ensure files exist for jq --rawfile
            [ -f .scratch/investigation-prompt.md ] || echo "" > .scratch/investigation-prompt.md
            [ -f .scratch/claude-output.log ] || echo "" > .scratch/claude-output.log
            [ -f .scratch/investigation-report.md ] || echo "" > .scratch/investigation-report.md

            # Extract PR number if PR was created
            PR_NUMBER=""
            if [ -n "$PR_URL" ]; then
              PR_NUMBER=$(echo "$PR_URL" | grep -o '[0-9]*$')
            fi

            RUN_UPDATE=$(jq -n \
              --arg status "$SPAWN_STATUS" \
              --arg outcome "${OUTCOME:-failed}" \
              --arg outcome_summary "$OUTCOME_SUMMARY" \
              --arg cost_usd "$COST_USD" \
              --arg num_turns "$NUM_TURNS" \
              --arg model "$MODEL" \
              --arg pr_number "$PR_NUMBER" \
              --rawfile prompt_text .scratch/investigation-prompt.md \
              --rawfile transcript .scratch/claude-output.log \
              --rawfile report_content .scratch/investigation-report.md \
              '{status: $status, outcome: $outcome, outcome_summary: $outcome_summary, cost_usd: ($cost_usd | tonumber), num_turns: ($num_turns | tonumber), model: $model, prompt_text: $prompt_text, transcript: $transcript, report_content: $report_content} + (if $pr_number != "" then {pr_number: ($pr_number | tonumber)} else {} end)')

            curl -sf -X PATCH "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/runs/${AGENT_RUN_ID}" \
              -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
              -H "Content-Type: application/json" \
              -d "$RUN_UPDATE" || echo "Warning: Failed to update run record (non-fatal)"
          fi

      - name: Upload full agent log
        if: always() && env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        run: |
          LOG_FILE=".scratch/claude-output.log"
          if [ ! -f "$LOG_FILE" ]; then
            echo "No output log found, skipping"
            exit 0
          fi

          FULL_SIZE=$(wc -c < "$LOG_FILE")

          # Truncate to ~500KB to stay within reasonable API limits
          head -c 512000 "$LOG_FILE" > .scratch/full-log-truncated.txt
          if [ "$FULL_SIZE" -gt 512000 ]; then
            echo "" >> .scratch/full-log-truncated.txt
            echo "... [truncated - full log was $(( FULL_SIZE / 1024 ))KB]" >> .scratch/full-log-truncated.txt
          fi

          jq -n \
            --arg type "agent_full_log" \
            --rawfile content .scratch/full-log-truncated.txt \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_url "$GITHUB_RUN_URL" \
            '{type: $type, content: $content, metadata: {run_id: $run_id, run_url: $run_url, workflow_type: "auto_investigate"}}' \
            > .scratch/full-log-payload.json

          curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/activity" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @.scratch/full-log-payload.json || echo "Warning: Failed to upload full log (non-fatal)"

          echo "Full log uploaded ($(( FULL_SIZE / 1024 ))KB)"

      - name: Report failure to Dispatch
        if: failure() && env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        run: |
          ERROR_TAIL=""
          if [ -f .scratch/claude-output.log ]; then
            ERROR_TAIL=$(tail -20 .scratch/claude-output.log)
          fi

          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          # Build failure activity JSON safely with jq
          FAILURE_PAYLOAD=$(jq -n \
            --arg type "investigation_failed" \
            --arg content "Workflow failed. Run: ${GITHUB_RUN_URL}" \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_url "$GITHUB_RUN_URL" \
            --arg error_tail "$ERROR_TAIL" \
            '{
              type: $type,
              content: $content,
              metadata: {
                run_id: $run_id,
                run_url: $run_url,
                error_tail: $error_tail
              }
            }')

          curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/activity" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$FAILURE_PAYLOAD" || echo "Warning: Failed to report failure to Dispatch (non-fatal)"

          STATUS_PAYLOAD=$(jq -n \
            --arg spawn_status "failed" \
            --arg spawn_completed_at "$TIMESTAMP" \
            '{spawn_status: $spawn_status, spawn_completed_at: $spawn_completed_at}')

          curl -sf -X PATCH "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$STATUS_PAYLOAD" || echo "Warning: Failed to update spawn status (non-fatal)"
