name: PRD Investigation

on:
  workflow_dispatch:
    inputs:
      issue_id:
        description: "Dispatch issue ID"
        required: true
        type: string
      issue_identifier:
        description: "Human-readable identifier (e.g. DISPATCH-456)"
        required: true
        type: string
      title:
        description: "Issue title / PRD summary"
        required: true
        type: string
      description:
        description: "Full PRD or feature description (markdown)"
        required: true
        type: string
      plan_feedback:
        description: "Human feedback from a previous plan rejection (optional)"
        required: false
        type: string
      additional_context:
        description: "Additional instructions from human retry (optional)"
        required: false
        type: string
      callback_url:
        description: "Override API callback URL (for local dev tunnels)"
        required: false
        type: string
      ref:
        description: "Git ref to checkout (branch, tag, or SHA). Defaults to the workflow dispatch ref."
        required: false
        type: string

# Only one investigation per issue at a time
concurrency:
  group: prd-investigate-${{ inputs.issue_identifier }}
  cancel-in-progress: false

jobs:
  investigate:
    name: Investigate ${{ inputs.issue_identifier }}
    runs-on: ubuntu-latest
    timeout-minutes: 30

    permissions:
      contents: read

    # SECURITY: All user-provided inputs are passed through env vars to
    # prevent command injection. They are NEVER interpolated in run: blocks.
    # See: https://github.blog/security/vulnerability-research/how-to-catch-github-actions-workflow-injections-before-attackers-do/
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      DISPATCH_API_URL: ${{ inputs.callback_url || secrets.DISPATCH_API_URL }}
      DISPATCH_API_KEY: ${{ secrets.DISPATCH_API_KEY }}
      DENO_NO_PACKAGE_JSON: "1"
      INPUT_ISSUE_ID: ${{ inputs.issue_id }}
      INPUT_ISSUE_IDENTIFIER: ${{ inputs.issue_identifier }}
      INPUT_TITLE: ${{ inputs.title }}
      INPUT_DESCRIPTION: ${{ inputs.description }}
      INPUT_PLAN_FEEDBACK: ${{ inputs.plan_feedback }}
      INPUT_ADDITIONAL_CONTEXT: ${{ inputs.additional_context }}
      GITHUB_RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref || github.ref_name }}
          fetch-depth: 0

      - name: Setup Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Notify Dispatch - Investigating
        if: env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        run: |
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          PAYLOAD=$(jq -n \
            --arg spawn_status "running" \
            --arg spawn_run_id "$GITHUB_RUN_ID" \
            --arg spawn_started_at "$TIMESTAMP" \
            --arg agent_status "investigating" \
            --arg spawn_type "investigate" \
            '{spawn_status: $spawn_status, spawn_run_id: $spawn_run_id, spawn_started_at: $spawn_started_at, agent_status: $agent_status, spawn_type: $spawn_type}')

          curl -sf -X PATCH "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" || echo "Warning: Failed to notify Dispatch (non-fatal)"

      - name: Build investigation prompt
        run: |
          mkdir -p .scratch

          # Build prompt file using jq for safe string handling (no shell interpolation of inputs)
          jq -n \
            --arg identifier "$INPUT_ISSUE_IDENTIFIER" \
            --arg title "$INPUT_TITLE" \
            --arg description "$INPUT_DESCRIPTION" \
            --arg feedback "$INPUT_PLAN_FEEDBACK" \
            --arg additional_context "$INPUT_ADDITIONAL_CONTEXT" \
            '{identifier: $identifier, title: $title, description: $description, feedback: $feedback, additional_context: $additional_context}' \
            > .scratch/prompt-data.json

          python3 -c "
          import json, sys
          d = json.load(open('.scratch/prompt-data.json'))
          feedback_section = ''
          if d['feedback']:
              feedback_section = f\"\"\"\n\nPrevious Plan Feedback (address these concerns):\n{d['feedback']}\n\"\"\"
          additional_section = ''
          if d.get('additional_context'):
              additional_section = f\"\"\"\n\nADDITIONAL CONTEXT FROM HUMAN:\n{d['additional_context']}\n\"\"\"
          prompt = f\"\"\"You are autonomously investigating a feature request / PRD for this project.
          Your goal is to explore the codebase and produce a STRUCTURED IMPLEMENTATION PLAN.
          You are READ-ONLY -- do NOT create branches, modify files, or write code.

          Issue: {d['identifier']} - {d['title']}

          Description / PRD:
          {d['description']}{feedback_section}{additional_section}

          Instructions:
          1. Read CLAUDE.md first to understand the codebase
          2. Explore all relevant files, services, routes, components, and database schemas
          3. Check for existing patterns, utilities, and conventions
          4. Identify environment variables, secrets, or external dependencies needed
          5. Write a STRUCTURED PLAN to .scratch/plan.md with these sections:

          ## Summary
          Brief description of what will be built.

          ## Files to Create
          - path/to/new/file.ts -- purpose

          ## Files to Modify
          - path/to/existing/file.ts -- what changes and why

          ## Database Changes
          Migration SQL or \"none\"

          ## API Changes
          New or modified endpoints

          ## UI Changes
          New or modified components

          ## Dependencies
          New packages, env vars, secrets needed

          ## Testing Strategy
          How to verify the implementation works

          ## Risks
          What could go wrong, edge cases

          ## Stop Conditions
          Conditions under which the implementation agent should STOP and report a blocker:
          - List specific scenarios (missing env vars, unclear requirements, etc.)

          ## Estimated Complexity
          Simple / Medium / Complex

          6. Do NOT attempt any code changes
          7. Do NOT create branches
          8. If you cannot understand the requirements well enough to plan, write that in the plan

          MANDATORY - RUN RESULT DECLARATION:
          Before exiting, you MUST write .scratch/run-result.json with:
          {{
            \"outcome\": \"investigation_complete|blocked|needs_human_decision|failed\",
            \"summary\": \"1-2 sentence explanation\",
            \"changes_made\": false,
            \"files_changed\": [],
            \"pr_needed\": false
          }}

          - Use \"investigation_complete\" if you produced a plan successfully.
          - Use \"blocked\" if requirements are unclear and you cannot plan.
          - Use \"needs_human_decision\" if there are multiple valid approaches and a human must choose.
          - Use \"failed\" if you could not complete the investigation.
          \"\"\"
          with open('.scratch/investigation-prompt.md', 'w') as f:
              f.write(prompt)
          "

      - name: Run Investigation
        id: investigate
        run: |
          # Create stream filter for human-readable output
          cat > .scratch/stream-filter.py << 'PYEOF'
          import sys, json
          for line in sys.stdin:
              line = line.strip()
              if not line: continue
              try:
                  event = json.loads(line)
                  t = event.get("type", "")
                  if t == "assistant":
                      for c in event.get("message", {}).get("content", []):
                          if c.get("type") == "text" and c.get("text"):
                              print(c["text"], flush=True)
                          elif c.get("type") == "tool_use":
                              name = c.get("name", "unknown")
                              inp = c.get("input", {})
                              parts = [f"{k}={str(v)[:80]}" for k, v in list(inp.items())[:3]]
                              print(f"[TOOL] {name}({', '.join(parts)})", flush=True)
                  elif t == "tool_result":
                      content = event.get("content", "")
                      if isinstance(content, list):
                          content = " ".join(c.get("text", "") for c in content if isinstance(c, dict))
                      preview = str(content)[:200] + ("..." if len(str(content)) > 200 else "")
                      print(f"[RESULT] {preview}", flush=True)
                  elif t == "result":
                      print(f"\n[COMPLETED] Cost: ${event.get('total_cost_usd', 0):.2f}, Turns: {event.get('num_turns', 0)}", flush=True)
              except (json.JSONDecodeError, KeyError):
                  print(line, flush=True)
          PYEOF

          # Claude CLI buffers ALL output when stdout is not a TTY.
          # Use `script` to create a pseudo-TTY, forcing line-buffered output.
          cat > .scratch/run-claude.sh << 'RUNEOF'
          #!/bin/bash
          PROMPT=$(cat .scratch/investigation-prompt.md)
          exec claude --print --model claude-opus-4-6 --verbose --output-format stream-json --dangerously-skip-permissions "$PROMPT"
          RUNEOF
          chmod +x .scratch/run-claude.sh

          script -qef .scratch/claude-raw.log -c "bash .scratch/run-claude.sh" > /dev/null 2>&1 &
          CLAUDE_PID=$!
          echo "Claude started (PID: $CLAUDE_PID)"

          PREV_LINES=0
          while kill -0 $CLAUDE_PID 2>/dev/null; do
            sleep 15
            [ -f .scratch/claude-raw.log ] || continue
            CURR_LINES=$(wc -l < .scratch/claude-raw.log)
            if [ "$CURR_LINES" -gt "$PREV_LINES" ]; then
              CHUNK=$(sed -n "$((PREV_LINES + 1)),${CURR_LINES}p" .scratch/claude-raw.log \
                | python3 -u .scratch/stream-filter.py)
              echo "$CHUNK"

              # Stream to Dispatch terminal viewer
              if [ -n "$CHUNK" ] && [ -n "$DISPATCH_API_URL" ] && [ -n "$DISPATCH_API_KEY" ]; then
                jq -n --arg content "$CHUNK" '{content: $content}' | \
                  curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/terminal" \
                    -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
                    -H "Content-Type: application/json" \
                    -d @- > /dev/null 2>&1 &
              fi

              PREV_LINES=$CURR_LINES
            else
              echo "[$(date -u +%H:%M:%S)] Claude working... ($CURR_LINES lines)"
            fi
          done
          wait $CLAUDE_PID
          CLAUDE_EXIT=$?
          echo "=== Claude exited with code $CLAUDE_EXIT ==="

          FINAL_LINES=$(wc -l < .scratch/claude-raw.log)
          if [ "$FINAL_LINES" -gt "$PREV_LINES" ]; then
            FINAL_CHUNK=$(sed -n "$((PREV_LINES + 1)),${FINAL_LINES}p" .scratch/claude-raw.log \
              | python3 -u .scratch/stream-filter.py)
            echo "$FINAL_CHUNK"
            if [ -n "$FINAL_CHUNK" ] && [ -n "$DISPATCH_API_URL" ] && [ -n "$DISPATCH_API_KEY" ]; then
              jq -n --arg content "$FINAL_CHUNK" '{content: $content}' | \
                curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/terminal" \
                  -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
                  -H "Content-Type: application/json" \
                  -d @- > /dev/null 2>&1 || true
            fi
          fi
          python3 -u .scratch/stream-filter.py < .scratch/claude-raw.log > .scratch/claude-output.log

          # Extract cost data from stream-json result event
          python3 -c "
          import json
          for line in open('.scratch/claude-raw.log'):
              line = line.strip()
              if not line: continue
              try:
                  event = json.loads(line)
                  if event.get('type') == 'result':
                      cost = event.get('total_cost_usd', 0)
                      turns = event.get('num_turns', 0)
                      model = event.get('model', 'unknown')
                      with open('.scratch/claude-cost.json', 'w') as f:
                          json.dump({'cost_usd': cost, 'num_turns': turns, 'model': model}, f)
                      print(f'Cost: \${cost:.4f}, Turns: {turns}, Model: {model}')
              except (json.JSONDecodeError, KeyError): pass
          " 2>/dev/null || echo "Warning: Could not extract cost data"

          exit $CLAUDE_EXIT

          # Ensure plan exists even if Claude didn't create one
          if [ ! -f .scratch/plan.md ]; then
            {
              echo "# Investigation Plan"
              echo ""
              echo "Claude Code did not produce a structured plan. Raw output saved to claude-output.log."
              echo ""
              echo '```'
              tail -100 .scratch/claude-output.log
              echo '```'
            } > .scratch/plan.md
          fi

      - name: Parse run result
        id: run-result
        if: always()
        run: |
          if [ ! -f .scratch/run-result.json ]; then
            echo "outcome=failed" >> "$GITHUB_OUTPUT"
            echo "Agent exited without declaring an outcome" > .scratch/outcome-summary.txt
            echo "pr_needed=false" >> "$GITHUB_OUTPUT"
            echo "changes_made=false" >> "$GITHUB_OUTPUT"
            echo "Run outcome: failed (no run-result.json)"
            exit 0
          fi

          OUTCOME=$(jq -r '.outcome // "failed"' .scratch/run-result.json)
          SUMMARY=$(jq -r '.summary // "No summary provided"' .scratch/run-result.json)
          PR_NEEDED=$(jq -r '.pr_needed // false' .scratch/run-result.json)
          CHANGES_MADE=$(jq -r '.changes_made // false' .scratch/run-result.json)

          case "$OUTCOME" in
            completed|no_changes_needed|blocked|needs_human_decision|investigation_complete|failed) ;;
            *) OUTCOME="failed"; SUMMARY="Invalid outcome: $OUTCOME" ;;
          esac

          echo "outcome=$OUTCOME" >> "$GITHUB_OUTPUT"
          echo "$SUMMARY" > .scratch/outcome-summary.txt
          echo "pr_needed=$PR_NEEDED" >> "$GITHUB_OUTPUT"
          echo "changes_made=$CHANGES_MADE" >> "$GITHUB_OUTPUT"

          echo "Run outcome: $OUTCOME"
          echo "Summary: $SUMMARY"

      - name: Post Plan to Dispatch
        if: always() && env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        env:
          JOB_STATUS: ${{ job.status }}
          OUTCOME: ${{ steps.run-result.outputs.outcome }}
        run: |
          if [ ! -f .scratch/plan.md ]; then
            echo "No plan file found." > .scratch/plan.md
          fi

          if [ "$JOB_STATUS" = "success" ]; then
            # Post the plan for review
            PLAN_PAYLOAD=$(jq -n \
              --arg action "submit" \
              --rawfile content .scratch/plan.md \
              '{action: $action, content: $content}')

            curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/plan" \
              -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
              -H "Content-Type: application/json" \
              -d "$PLAN_PAYLOAD" || echo "Warning: Failed to post plan (non-fatal)"

            SPAWN_STATUS="completed"
          else
            SPAWN_STATUS="failed"
          fi

          # Read cost data if available
          COST_USD="0"
          NUM_TURNS="0"
          MODEL="unknown"
          if [ -f .scratch/claude-cost.json ]; then
            COST_USD=$(jq -r '.cost_usd // 0' .scratch/claude-cost.json)
            NUM_TURNS=$(jq -r '.num_turns // 0' .scratch/claude-cost.json)
            MODEL=$(jq -r '.model // "unknown"' .scratch/claude-cost.json)
          fi

          # Post activity log
          ACTIVITY_PAYLOAD=$(jq -n \
            --arg type "investigation_complete" \
            --rawfile content .scratch/plan.md \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_url "$GITHUB_RUN_URL" \
            --arg cost_usd "$COST_USD" \
            --arg num_turns "$NUM_TURNS" \
            --arg model "$MODEL" \
            '{type: $type, content: $content, metadata: {run_id: $run_id, run_url: $run_url, workflow_type: "prd_investigate", cost_usd: $cost_usd, num_turns: $num_turns, model: $model}}')

          curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/activity" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$ACTIVITY_PAYLOAD" || echo "Warning: Failed to post activity (non-fatal)"

          # Read outcome summary from file
          OUTCOME_SUMMARY=""
          if [ -f .scratch/outcome-summary.txt ]; then
            OUTCOME_SUMMARY=$(cat .scratch/outcome-summary.txt)
          fi

          # Update spawn status with cost data and outcome
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          STATUS_PAYLOAD=$(jq -n \
            --arg spawn_status "$SPAWN_STATUS" \
            --arg spawn_completed_at "$TIMESTAMP" \
            --arg cost_usd "$COST_USD" \
            --arg num_turns "$NUM_TURNS" \
            --arg model "$MODEL" \
            --arg run_outcome "${OUTCOME:-failed}" \
            --arg outcome_summary "$OUTCOME_SUMMARY" \
            '{spawn_status: $spawn_status, spawn_completed_at: $spawn_completed_at, cost_usd: $cost_usd, num_turns: $num_turns, model: $model, run_outcome: $run_outcome, outcome_summary: $outcome_summary}')

          curl -sf -X PATCH "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$STATUS_PAYLOAD" || echo "Warning: Failed to update spawn status (non-fatal)"

      - name: Report failure
        if: failure() && env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        run: |
          ERROR_TAIL=""
          if [ -f .scratch/claude-output.log ]; then
            ERROR_TAIL=$(tail -20 .scratch/claude-output.log)
          fi

          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          FAILURE_PAYLOAD=$(jq -n \
            --arg type "investigation_failed" \
            --arg content "PRD investigation workflow failed." \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_url "$GITHUB_RUN_URL" \
            --arg error_tail "$ERROR_TAIL" \
            '{type: $type, content: $content, metadata: {run_id: $run_id, run_url: $run_url, error_tail: $error_tail}}')

          curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/activity" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$FAILURE_PAYLOAD" || true

          STATUS_PAYLOAD=$(jq -n \
            --arg spawn_status "failed" \
            --arg spawn_completed_at "$TIMESTAMP" \
            --arg agent_status "idle" \
            '{spawn_status: $spawn_status, spawn_completed_at: $spawn_completed_at, agent_status: $agent_status}')

          curl -sf -X PATCH "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$STATUS_PAYLOAD" || true
