name: PRD Implementation

on:
  workflow_dispatch:
    inputs:
      issue_id:
        description: "Dispatch issue ID"
        required: true
        type: string
      issue_identifier:
        description: "Human-readable identifier (e.g. DISPATCH-456)"
        required: true
        type: string
      title:
        description: "Issue title / PRD summary"
        required: true
        type: string
      description:
        description: "Full PRD or feature description (markdown)"
        required: true
        type: string
      plan_content:
        description: "Approved implementation plan (markdown)"
        required: true
        type: string
      additional_context:
        description: "Additional instructions from human retry (optional)"
        required: false
        type: string
      callback_url:
        description: "Override API callback URL (for local dev tunnels)"
        required: false
        type: string
      ref:
        description: "Git ref to checkout (branch, tag, or SHA). Defaults to the workflow dispatch ref."
        required: false
        type: string

# Only one implementation per issue at a time
concurrency:
  group: prd-implement-${{ inputs.issue_identifier }}
  cancel-in-progress: false

jobs:
  implement:
    name: Implement ${{ inputs.issue_identifier }}
    runs-on: ubuntu-latest
    timeout-minutes: 60

    permissions:
      contents: write
      pull-requests: write

    # SECURITY: All user-provided inputs are passed through env vars to
    # prevent command injection. They are NEVER interpolated in run: blocks.
    # See: https://github.blog/security/vulnerability-research/how-to-catch-github-actions-workflow-injections-before-attackers-do/
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      DISPATCH_API_URL: ${{ inputs.callback_url || secrets.DISPATCH_API_URL }}
      DISPATCH_API_KEY: ${{ secrets.DISPATCH_API_KEY }}
      DENO_NO_PACKAGE_JSON: "1"
      INPUT_ISSUE_ID: ${{ inputs.issue_id }}
      INPUT_ISSUE_IDENTIFIER: ${{ inputs.issue_identifier }}
      INPUT_TITLE: ${{ inputs.title }}
      INPUT_DESCRIPTION: ${{ inputs.description }}
      INPUT_PLAN_CONTENT: ${{ inputs.plan_content }}
      INPUT_ADDITIONAL_CONTEXT: ${{ inputs.additional_context }}
      GITHUB_RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
      MAX_AGENT_COST_PER_RUN: ${{ vars.MAX_AGENT_COST_PER_RUN || '25' }}

    services:
      postgres:
        image: pgvector/pgvector:pg16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: dispatch
        ports:
          - 5436:5432
        options: >-
          --health-cmd "pg_isready -U postgres"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref || github.ref_name }}
          fetch-depth: 0

      - name: Setup Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Install MCP browser-devtools dependencies
        run: cd tools/mcp-browser-devtools && npm ci

      - name: Pre-cache Deno MCP server dependencies
        run: |
          # Download and compile npm packages ahead of time so the MCP server
          # starts instantly when Claude launches it (no network fetch at runtime)
          deno cache tools/mcp-database/index.ts
          echo "Deno MCP server dependencies cached"

      - name: Register MCP servers
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/dispatch
        run: |
          # Register MCP servers at user scope to avoid project-scope approval prompts.
          # Project-scoped servers (.mcp.json) require interactive approval which blocks CI.
          # User-scoped servers are pre-approved.
          claude mcp add-json browser-devtools '{"type":"stdio","command":"node","args":["tools/mcp-browser-devtools/index.js"],"env":{"CDP_HOST":"localhost","CDP_PORT":"9222"}}'
          claude mcp add-json dispatch-database '{"type":"stdio","command":"deno","args":["run","--allow-net","--allow-env","--allow-read","tools/mcp-database/index.ts"],"env":{"DATABASE_URL":"postgresql://postgres:postgres@localhost:5436/dispatch"}}'

          # Remove project .mcp.json to avoid duplicate server registration
          rm -f .mcp.json

          # Verify servers are registered
          claude mcp list

      - name: Sanitize branch name
        id: branch
        run: |
          SAFE_ID=$(echo "$INPUT_ISSUE_IDENTIFIER" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/-\+/-/g' | sed 's/^-//;s/-$//')
          echo "name=feat/${SAFE_ID}" >> "$GITHUB_OUTPUT"
          echo "Branch name: feat/${SAFE_ID}"

      - name: Notify Dispatch - Implementing
        if: env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        run: |
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          PAYLOAD=$(jq -n \
            --arg spawn_status "running" \
            --arg spawn_run_id "$GITHUB_RUN_ID" \
            --arg spawn_started_at "$TIMESTAMP" \
            --arg agent_status "implementing" \
            --arg spawn_type "implement" \
            '{spawn_status: $spawn_status, spawn_run_id: $spawn_run_id, spawn_started_at: $spawn_started_at, agent_status: $agent_status, spawn_type: $spawn_type}')

          curl -sf -X PATCH "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" || echo "Warning: Failed to notify Dispatch (non-fatal)"

      - name: Link Run Record
        if: env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        run: |
          LINK_PAYLOAD=$(jq -n --arg github_run_id "$GITHUB_RUN_ID" --arg github_run_url "$GITHUB_RUN_URL" '{github_run_id: $github_run_id, github_run_url: $github_run_url}')
          curl -sf -X PATCH "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/runs/current" -H "Authorization: Bearer ${DISPATCH_API_KEY}" -H "Content-Type: application/json" -d "$LINK_PAYLOAD" || echo "Warning: Failed to link run record (non-fatal)"

      - name: Post Run Context
        if: env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        run: |
          mkdir -p .scratch
          python3 -c "
          import os
          fields = []
          fields.append(('Workflow', 'prd_implement'))
          fields.append(('Issue', os.environ.get('INPUT_ISSUE_IDENTIFIER', '')))
          fields.append(('Run', os.environ.get('GITHUB_RUN_URL', '')))
          fields.append(('Title', os.environ.get('INPUT_TITLE', '')))
          desc = os.environ.get('INPUT_DESCRIPTION', '')
          if desc:
              preview = desc[:500] + ('...' if len(desc) > 500 else '')
              fields.append(('Description', preview))
          plan = os.environ.get('INPUT_PLAN_CONTENT', '')
          if plan:
              preview = plan[:1000] + ('...' if len(plan) > 1000 else '')
              fields.append(('Plan Content', preview))
          ctx = os.environ.get('INPUT_ADDITIONAL_CONTEXT', '')
          if ctx:
              fields.append(('Additional Context', ctx))
          lines = ['=' * 60, 'RUN CONTEXT', '=' * 60]
          for label, value in fields:
              if '\n' in value:
                  lines.append(f'{label}:')
                  for line in value.split('\n')[:30]:
                      lines.append(f'  {line}')
                  if value.count('\n') > 30:
                      lines.append('  ...(truncated)')
              else:
                  lines.append(f'{label}: {value}')
          lines.append('=' * 60)
          with open('.scratch/run-context.txt', 'w') as f:
              f.write('\n'.join(lines))
          print('\n'.join(lines))
          "
          jq -n --rawfile content .scratch/run-context.txt '{content: $content}' | \
            curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/terminal" \
              -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
              -H "Content-Type: application/json" \
              -d @- || echo "Warning: Failed to post run context (non-fatal)"

      - name: Setup database
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/dispatch
        run: |
          # Run migrations to set up the schema
          deno task db:migrate || echo "Warning: Migration failed (may need manual schema setup)"

      - name: Seed test data
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/dispatch
        run: |
          psql "$DATABASE_URL" -f scripts/seed-test-data.sql

      - name: Install web dependencies
        run: cd web && npm ci

      - name: Start dev servers
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/dispatch
          NODE_ENV: development
          PORT: "8000"
        run: |
          mkdir -p .scratch/logs

          # Start Deno API server (with --watch so it picks up Claude's changes)
          deno task dev > .scratch/logs/api-server.log 2>&1 &
          echo "API server started (PID: $!)"

          # Start Vite dev server (use absolute path for log since we cd)
          LOGDIR="$(pwd)/.scratch/logs"
          (cd web && npm run dev > "$LOGDIR/vite-server.log" 2>&1) &
          echo "Vite server started (PID: $!)"

          # Health check API server (wait up to 30s)
          echo "Waiting for API server at localhost:8000..."
          for i in $(seq 1 30); do
            if curl -sf http://localhost:8000/health > /dev/null 2>&1; then
              echo "API server ready after ${i}s"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "WARNING: API server not responding after 30s"
              cat .scratch/logs/api-server.log 2>/dev/null || echo "(no log file)"
            fi
            sleep 1
          done

          # Health check Vite server (wait up to 30s)
          echo "Waiting for Vite server at localhost:5173..."
          for i in $(seq 1 30); do
            if curl -sf http://localhost:5173 > /dev/null 2>&1; then
              echo "Vite server ready after ${i}s"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "WARNING: Vite server not responding after 30s"
              cat .scratch/logs/vite-server.log 2>/dev/null || echo "(no log file)"
            fi
            sleep 1
          done

          echo "Dev servers are running."

      - name: Start Chrome for browser testing
        run: |
          # Chrome is pre-installed on ubuntu-latest; start after dev servers are up
          google-chrome --headless --no-sandbox --disable-gpu \
            --disable-dbus \
            --remote-debugging-port=9222 \
            --remote-debugging-address=127.0.0.1 \
            about:blank &

          # Wait for DevTools Protocol to be ready (up to 15s)
          echo "Waiting for Chrome DevTools at localhost:9222..."
          for i in $(seq 1 15); do
            if curl -sf http://localhost:9222/json/version > /dev/null 2>&1; then
              echo "Chrome DevTools ready after ${i}s"
              curl -sf http://localhost:9222/json/version
              break
            fi
            if [ $i -eq 15 ]; then
              echo "WARNING: Chrome DevTools not responding after 15s"
            fi
            sleep 1
          done

      - name: Build implementation prompt
        run: |
          mkdir -p .scratch

          # Build prompt data using jq for safe string handling (no shell interpolation of inputs)
          jq -n \
            --arg identifier "$INPUT_ISSUE_IDENTIFIER" \
            --arg title "$INPUT_TITLE" \
            --arg description "$INPUT_DESCRIPTION" \
            --arg plan "$INPUT_PLAN_CONTENT" \
            --arg additional_context "$INPUT_ADDITIONAL_CONTEXT" \
            '{identifier: $identifier, title: $title, description: $description, plan: $plan, additional_context: $additional_context}' \
            > .scratch/prompt-data.json

          # Use heredoc with single-quoted delimiter to prevent bash expansion of backticks
          python3 << 'PYEOF'
          import json
          d = json.load(open('.scratch/prompt-data.json'))
          identifier = d['identifier']
          branch_id = identifier.lower().replace(' ', '-')
          prompt = f"""You are autonomously implementing an approved feature plan for this project.
          You MUST follow the approved plan closely. Do NOT deviate from it without good reason.

          Issue: {identifier} - {d['title']}

          Description / PRD:
          {d['description']}

          APPROVED IMPLEMENTATION PLAN:
          {d['plan']}
          """ + (f"""
          ADDITIONAL CONTEXT FROM HUMAN:
          {d['additional_context']}
          """ if d.get('additional_context') else "") + """

          RUNNING ENVIRONMENT:
          A full-stack dev environment is running and available:
          - API server: http://localhost:8000 (Deno with --watch, auto-reloads on file changes)
          - Frontend: http://localhost:5173 (Vite dev server, hot module reload)
          - Database: postgresql://postgres:postgres@localhost:5436/dispatch (seeded with test data)
          - Chrome: headless Chrome with DevTools Protocol on port 9222
          - Server logs: .scratch/logs/api-server.log and .scratch/logs/vite-server.log

          BROWSER TESTING (MCP tools available):
          You have access to browser-devtools MCP tools for interacting with Chrome.
          Use these tools -- do NOT write puppeteer scripts:
          - mcp__browser-devtools__browser_navigate: Navigate to a URL
          - mcp__browser-devtools__browser_take_screenshot: Take a screenshot (saves to .scratch/screenshots/)
          - mcp__browser-devtools__browser_click: Click elements by CSS selector or text
          - mcp__browser-devtools__browser_type: Type into input fields
          - mcp__browser-devtools__browser_get_element: Inspect element text/attributes
          - mcp__browser-devtools__browser_wait_for: Wait for elements to appear
          - mcp__browser-devtools__browser_get_console_logs: Check for console errors
          - mcp__browser-devtools__browser_get_network_requests: Check API calls
          - mcp__browser-devtools__browser_execute_js: Run JS in the browser context
          Use these to verify your implementation works visually before committing.

          DATABASE (MCP tools available):
          You have access to dispatch-database MCP tools:
          - mcp__dispatch-database__db_query: Run SELECT queries
          - mcp__dispatch-database__db_execute: Run INSERT/UPDATE/DELETE
          - mcp__dispatch-database__db_list_tables: List tables
          - mcp__dispatch-database__db_describe_table: Show table schema
          Use these to verify database changes work correctly.

          Test data in the database:
          - Organization: id=11111111-1111-1111-1111-111111111111, name='Test Organization'
          - User: id=22222222-2222-2222-2222-222222222222, email='test-developer@example.com'
          - Application: id=00000000-0000-0000-0000-000000000003, app_name_id='test-chat-app'
          - Consumer: id=44444444-4444-4444-4444-444444444444, email='test-consumer@example.com'
          - Session: id=00000000-0000-0000-0000-000000000005 (valid for 30 days)

          Instructions:
          1. Read CLAUDE.md first to understand the codebase conventions
          2. Follow the plan step by step:
             - Create files listed in 'Files to Create'
             - Modify files listed in 'Files to Modify'
             - Create database migrations if listed in 'Database Changes'
             - Follow existing code patterns and conventions
          4. After implementing, you MUST verify your work by running the FULL PR check suite.
             These are the exact checks that will run on your PR -- ALL must pass:
             a. deno check main.ts          (type checking)
             b. deno lint                    (linting -- covers src/ AND dispatch/)
             c. deno test --allow-net --allow-env --allow-read --allow-write --allow-ffi src/__tests__/llm/normalization/ src/__tests__/llm/normalize_history_test.ts
             d. cd web && npm run check && npm run build  (Svelte type check + build -- npm ci already done)
             If ANY check fails, fix the issue and re-run ALL checks until they pass.
             Fix pre-existing failures too -- the PR must be green.
          5. Stage and commit: git add -A && git commit -m "feat: description [{identifier}]"
          6. Do NOT push branches - just prepare commits locally
          7. Do NOT run git checkout or git branch - stay on the current branch at all times

          GIT WORKFLOW (CRITICAL - READ THIS):
          If you change ANY file, you MUST commit before exiting.
          The workflow CANNOT create a PR from uncommitted changes. If you edit files
          but do not commit, your work is lost. The sequence is ALWAYS:
            # ... make changes, run checks ...
            git add -A
            git commit -m "feat: description [{identifier}]"
          Then set pr_needed=true in run-result.json. No commit = no PR = wasted work.
          Do NOT create branches -- the workflow handles that after you exit.

          EVIDENCE & PR SUMMARY (MANDATORY):
          After ALL implementation and checks pass, you MUST write .scratch/implementation-summary.md.
          This file becomes the PR description that humans review. Include these sections:
          - Original Intent (2-3 sentences: what was requested and why -- quote or paraphrase the
            issue/PRD so the reviewer understands the goal without opening the Dispatch issue)
          - What Changed (2-4 sentence summary of the implementation approach)
          - Changes (table of files and what changed)
          - How It Works (technical approach, 3-5 sentences)
          - Verification: PR Checks (deno check, deno lint, deno test, svelte build - pass/fail)
          - Verification: Evidence (see below)
          - Potential Risks (breaking changes, performance, security, edge cases)

          FOR UI CHANGES (MANDATORY SCREENSHOTS):
          Use the browser-devtools MCP tools to test and screenshot your changes:
          1. Navigate to the changed page with browser_navigate
          2. Interact with UI elements: browser_click, browser_type, browser_wait_for
          3. Take screenshots with browser_take_screenshot
          4. Check for console errors with browser_get_console_logs
          Save screenshots to .scratch/screenshots/ and reference them in the summary.
          You MUST take at least one screenshot for any change that affects the UI.

          FOR DATABASE CHANGES: Use the dispatch-database MCP tools:
          1. Run the migration: deno task db:migrate
          2. Verify with db_query or db_describe_table
          Paste the query results in the summary as proof.

          FOR API CHANGES: The API server is running at http://localhost:8000.
          Use curl to hit the actual running endpoints and paste the responses.

          ENVIRONMENT VARIABLES:
          If you need an environment variable, FIRST read .env and .env.example to check what is
          already configured. Many variables are already set in the CI environment. Only report a
          missing env var as a blocker AFTER checking both files. If a variable exists in .env but
          is empty or has a placeholder value, that counts as missing -- stop and report it.

          PRE-EXISTING ISSUES:
          If you encounter a pre-existing bug, wrong env var name, broken import, or misconfiguration
          during your work, FIX IT. Do not work around it. Do not say "this is pre-existing so we'll
          leave it." Every issue you find gets fixed in the same PR.

          CRITICAL STOP CONDITIONS:
          If you encounter ANY of the following, STOP IMMEDIATELY:
          - Missing environment variables or secrets (after checking .env and .env.example)
          - Requirements that are unclear or contradictory
          - Dependencies that are not available or cannot be installed
          - Test failures that indicate a fundamental design issue
          - Design decisions that are not covered by the plan
          - Work that is clearly out of scope of the plan

          When you must STOP:
          1. Write a detailed explanation to .scratch/blocker.md with:
             - Category: missing_env | unclear_requirement | missing_dependency | test_failure | design_decision | out_of_scope
             - What you were trying to do
             - What went wrong
             - What information or decision you need from a human
          2. Exit immediately after writing the blocker file

          IMPORTANT: Working around blockers instead of reporting them is a FAILURE.
          It is better to stop and ask for help than to produce incorrect or incomplete work.

          MANDATORY - RUN RESULT DECLARATION:
          Before exiting, you MUST write .scratch/run-result.json with:
          {{
            "outcome": "completed|no_changes_needed|blocked|needs_human_decision|investigation_complete|failed",
            "summary": "1-2 sentence explanation of your decision",
            "changes_made": true/false,
            "files_changed": ["list", "of", "paths"],
            "pr_needed": true/false
          }}

          Outcome values:
          - "completed": You made code changes and committed them. Set pr_needed=true.
          - "no_changes_needed": The feature/fix already exists or is not applicable. Set pr_needed=false.
          - "blocked": You hit a stop condition and wrote .scratch/blocker.md. Set pr_needed=false.
          - "needs_human_decision": The situation is ambiguous and a human should decide. Set pr_needed=false.
          - "failed": You could not complete the task. Set pr_needed=false.

          You MUST write this file even if you also wrote a blocker file.

          OFF-LIMITS FILES (do NOT modify):
          - .github/ (workflow files - CI/CD config)
          - .mcp.json (MCP server config - managed by CI)
          - scripts/ (dev scripts - not your concern)
          """
          with open('.scratch/implementation-prompt.md', 'w') as f:
              f.write(prompt)
          PYEOF

      - name: Run Implementation
        id: implement
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/dispatch
          BRANCH_NAME: ${{ steps.branch.outputs.name }}
        run: |
          mkdir -p .scratch/screenshots

          # Create a stream-json to human-readable filter script
          cat > .scratch/stream-filter.py << 'PYEOF'
          import sys, json
          for line in sys.stdin:
              line = line.strip()
              if not line:
                  continue
              try:
                  event = json.loads(line)
                  t = event.get("type", "")
                  if t == "assistant":
                      msg = event.get("message", {})
                      for c in msg.get("content", []):
                          if c.get("type") == "text" and c.get("text"):
                              print(c["text"], flush=True)
                          elif c.get("type") == "tool_use":
                              name = c.get("name", "unknown")
                              inp = c.get("input", {})
                              # Show a compact summary of tool calls
                              summary_parts = []
                              for k, v in list(inp.items())[:3]:
                                  val = str(v)[:80]
                                  summary_parts.append(f"{k}={val}")
                              summary = ", ".join(summary_parts)
                              print(f"[TOOL] {name}({summary})", flush=True)
                  elif t == "tool_result":
                      # Show brief tool result (truncated)
                      content = event.get("content", "")
                      if isinstance(content, list):
                          content = " ".join(c.get("text", "") for c in content if isinstance(c, dict))
                      preview = str(content)[:200]
                      if len(str(content)) > 200:
                          preview += "..."
                      print(f"[RESULT] {preview}", flush=True)
                  elif t == "result":
                      cost = event.get("total_cost_usd", 0)
                      turns = event.get("num_turns", 0)
                      print(f"\n[COMPLETED] Cost: ${cost:.2f}, Turns: {turns}", flush=True)
              except (json.JSONDecodeError, KeyError):
                  # Not JSON or unexpected format - print as-is
                  print(line, flush=True)
          PYEOF

          # Quick MCP readiness check (servers registered at user scope - no approval needed)
          echo "=== MCP readiness check ==="
          timeout 60 claude --print --model claude-opus-4-6 --dangerously-skip-permissions --max-budget-usd "${MAX_AGENT_COST_PER_RUN:-25}" \
            "List your available MCP tools. Respond with the count of MCP tools you have access to." 2>&1 \
            && echo "MCP check: PASS" || echo "MCP check: FAIL (exit: $?)"

          echo ""
          echo "=== Starting Implementation ==="
          PROMPT=$(cat .scratch/implementation-prompt.md)

          # Servers are registered at user scope (via `claude mcp add-json` above).
          # No --mcp-config flag needed - Claude auto-discovers user-scoped servers.
          claude --print --model claude-opus-4-6 --verbose --output-format stream-json --dangerously-skip-permissions --max-budget-usd "${MAX_AGENT_COST_PER_RUN:-25}" \
            "$PROMPT" > .scratch/claude-raw.log 2>&1 &
          CLAUDE_PID=$!
          echo "Claude started (PID: $CLAUDE_PID)"

          # Stream new output lines through the human-readable filter every 10s
          # Also POST chunks to Dispatch for live terminal viewing
          PREV_LINES=0
          while kill -0 $CLAUDE_PID 2>/dev/null; do
            sleep 10
            [ -f .scratch/claude-raw.log ] || continue
            CURR_LINES=$(wc -l < .scratch/claude-raw.log 2>/dev/null || echo 0)
            if [ "$CURR_LINES" -gt "$PREV_LINES" ]; then
              CHUNK=$(sed -n "$((PREV_LINES + 1)),${CURR_LINES}p" .scratch/claude-raw.log \
                | python3 -u .scratch/stream-filter.py)
              echo "$CHUNK"

              # Stream to Dispatch terminal viewer (non-blocking, fire-and-forget)
              if [ -n "$CHUNK" ] && [ -n "$DISPATCH_API_URL" ] && [ -n "$DISPATCH_API_KEY" ]; then
                jq -n --arg content "$CHUNK" '{content: $content}' | \
                  curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/terminal" \
                    -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
                    -H "Content-Type: application/json" \
                    -d @- > /dev/null 2>&1 &
              fi

              PREV_LINES=$CURR_LINES
            fi
          done
          wait $CLAUDE_PID
          CLAUDE_EXIT=$?

          # Flush any remaining lines after exit
          [ -f .scratch/claude-raw.log ] && {
            FINAL_LINES=$(wc -l < .scratch/claude-raw.log 2>/dev/null || echo 0)
            if [ "$FINAL_LINES" -gt "$PREV_LINES" ]; then
              FINAL_CHUNK=$(sed -n "$((PREV_LINES + 1)),${FINAL_LINES}p" .scratch/claude-raw.log \
                | python3 -u .scratch/stream-filter.py)
              echo "$FINAL_CHUNK"
              if [ -n "$FINAL_CHUNK" ] && [ -n "$DISPATCH_API_URL" ] && [ -n "$DISPATCH_API_KEY" ]; then
                jq -n --arg content "$FINAL_CHUNK" '{content: $content}' | \
                  curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/terminal" \
                    -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
                    -H "Content-Type: application/json" \
                    -d @- > /dev/null 2>&1 || true
              fi
            fi
          }

          echo ""
          echo "=== Claude exited with code $CLAUDE_EXIT ==="

          # Generate readable log from raw JSON
          python3 -u .scratch/stream-filter.py < .scratch/claude-raw.log > .scratch/claude-output.log 2>/dev/null || cp .scratch/claude-raw.log .scratch/claude-output.log

          # Extract cost and turn count from the stream-json result event
          python3 -c "
          import json, sys
          for line in open('.scratch/claude-raw.log'):
              line = line.strip()
              if not line: continue
              try:
                  event = json.loads(line)
                  if event.get('type') == 'result':
                      cost = event.get('total_cost_usd', 0)
                      turns = event.get('num_turns', 0)
                      model = event.get('model', 'unknown')
                      with open('.scratch/claude-cost.json', 'w') as f:
                          json.dump({'cost_usd': cost, 'num_turns': turns, 'model': model}, f)
                      print(f'Cost: \${cost:.4f}, Turns: {turns}, Model: {model}')
              except (json.JSONDecodeError, KeyError):
                  pass
          " 2>/dev/null || echo "Warning: Could not extract cost data"

          exit $CLAUDE_EXIT

      - name: Parse run result
        id: run-result
        if: always()
        run: |
          if [ ! -f .scratch/run-result.json ]; then
            echo "outcome=failed" >> "$GITHUB_OUTPUT"
            echo "Agent exited without declaring an outcome" > .scratch/outcome-summary.txt
            echo "pr_needed=false" >> "$GITHUB_OUTPUT"
            echo "changes_made=false" >> "$GITHUB_OUTPUT"
            echo "Run outcome: failed (no run-result.json)"
            exit 0
          fi

          OUTCOME=$(jq -r '.outcome // "failed"' .scratch/run-result.json)
          SUMMARY=$(jq -r '.summary // "No summary provided"' .scratch/run-result.json)
          PR_NEEDED=$(jq -r '.pr_needed // false' .scratch/run-result.json)
          CHANGES_MADE=$(jq -r '.changes_made // false' .scratch/run-result.json)

          # Validate outcome
          case "$OUTCOME" in
            completed|no_changes_needed|blocked|needs_human_decision|investigation_complete|failed) ;;
            *) OUTCOME="failed"; SUMMARY="Invalid outcome: $OUTCOME" ;;
          esac

          echo "outcome=$OUTCOME" >> "$GITHUB_OUTPUT"
          echo "$SUMMARY" > .scratch/outcome-summary.txt
          echo "pr_needed=$PR_NEEDED" >> "$GITHUB_OUTPUT"
          echo "changes_made=$CHANGES_MADE" >> "$GITHUB_OUTPUT"

          echo "Run outcome: $OUTCOME"
          echo "Summary: $SUMMARY"

      - name: Verify PR checks pass
        id: verify
        if: steps.run-result.outputs.changes_made == 'true'
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/dispatch
        run: |
          echo "Running PR check suite to verify implementation..."
          FAILURES=""

          echo "=== deno check main.ts ==="
          if ! deno check main.ts 2>&1 | tee .scratch/verify-typecheck.log; then
            FAILURES="${FAILURES}deno-check "
          fi

          echo "=== deno lint ==="
          if ! deno lint 2>&1 | tee .scratch/verify-lint.log; then
            FAILURES="${FAILURES}deno-lint "
          fi

          echo "=== deno test ==="
          if ! deno test --allow-net --allow-env --allow-read --allow-write --allow-ffi \
            src/__tests__/llm/normalization/ \
            src/__tests__/llm/normalize_history_test.ts 2>&1 | tee .scratch/verify-test.log; then
            FAILURES="${FAILURES}deno-test "
          fi

          echo "=== svelte build ==="
          if ! (cd web && npm run check && npm run build) 2>&1 | tee .scratch/verify-svelte.log; then
            FAILURES="${FAILURES}svelte-build "
          fi

          if [ -n "$FAILURES" ]; then
            echo "FAILED CHECKS: $FAILURES"
            echo "checks_failed=true" >> "$GITHUB_OUTPUT"
            echo "$FAILURES" > .scratch/failed-checks.txt
          else
            echo "All PR checks passed!"
            echo "checks_failed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Fix failing checks
        if: steps.verify.outputs.checks_failed == 'true' && steps.run-result.outputs.changes_made == 'true'
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/dispatch
        run: |
          FAILURES=$(cat .scratch/failed-checks.txt)
          FIX_PROMPT="The implementation is complete but the following PR checks are failing: ${FAILURES}

          Fix ALL failing checks. Here are the logs:

          $([ -f .scratch/verify-typecheck.log ] && echo '--- deno check ---' && tail -30 .scratch/verify-typecheck.log)
          $([ -f .scratch/verify-lint.log ] && echo '--- deno lint ---' && tail -50 .scratch/verify-lint.log)
          $([ -f .scratch/verify-test.log ] && echo '--- deno test ---' && tail -30 .scratch/verify-test.log)
          $([ -f .scratch/verify-svelte.log ] && echo '--- svelte build ---' && tail -30 .scratch/verify-svelte.log)

          Fix every error, even pre-existing ones. The PR must pass all checks.
          After fixing, commit with a message like 'fix: resolve PR check failures for ISSUE_ID'.
          Do NOT push."

          # Write prompt to file to avoid shell quoting issues
          printf '%s' "$FIX_PROMPT" > .scratch/fix-prompt.md
          PREV_FIX_LINES=$(wc -l < .scratch/claude-raw.log 2>/dev/null || echo 0)

          # Run fix attempt (MCP servers auto-discovered from user config)
          claude --print --model claude-opus-4-6 --verbose --output-format stream-json --dangerously-skip-permissions --max-budget-usd "${MAX_AGENT_COST_PER_RUN:-25}" \
            "$(cat .scratch/fix-prompt.md)" > .scratch/claude-fix-raw.log 2>&1 &
          FIX_PID=$!

          PREV_FIX_LINES=0
          while kill -0 $FIX_PID 2>/dev/null; do
            sleep 15
            [ -f .scratch/claude-fix-raw.log ] || continue
            CURR=$(wc -l < .scratch/claude-fix-raw.log)
            if [ "$CURR" -gt "$PREV_FIX_LINES" ]; then
              sed -n "$((PREV_FIX_LINES + 1)),${CURR}p" .scratch/claude-fix-raw.log \
                | python3 -u .scratch/stream-filter.py
              PREV_FIX_LINES=$CURR
            fi
          done
          wait $FIX_PID || true

          FINAL=$(wc -l < .scratch/claude-fix-raw.log)
          if [ "$FINAL" -gt "$PREV_FIX_LINES" ]; then
            sed -n "$((PREV_FIX_LINES + 1)),${FINAL}p" .scratch/claude-fix-raw.log \
              | python3 -u .scratch/stream-filter.py
          fi

          # Merge fix log into main log, then regenerate readable output
          cat .scratch/claude-fix-raw.log >> .scratch/claude-raw.log
          python3 -u .scratch/stream-filter.py < .scratch/claude-raw.log > .scratch/claude-output.log

      - name: Re-verify after fix
        if: steps.verify.outputs.checks_failed == 'true' && steps.run-result.outputs.changes_made == 'true'
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/dispatch
        run: |
          echo "Re-running PR check suite after fix attempt..."
          STILL_FAILING=""

          deno check main.ts 2>&1 || STILL_FAILING="${STILL_FAILING}deno-check "
          deno lint 2>&1 || STILL_FAILING="${STILL_FAILING}deno-lint "
          deno test --allow-net --allow-env --allow-read --allow-write --allow-ffi \
            src/__tests__/llm/normalization/ \
            src/__tests__/llm/normalize_history_test.ts 2>&1 || STILL_FAILING="${STILL_FAILING}deno-test "
          (cd web && npm run check && npm run build) 2>&1 || STILL_FAILING="${STILL_FAILING}svelte-build "

          if [ -n "$STILL_FAILING" ]; then
            echo "WARNING: Still failing after fix: $STILL_FAILING"
            echo "Proceeding anyway - PR will show failures for human review."
          else
            echo "All checks pass after fix!"
          fi

      - name: Check for blocker
        id: check-blocker
        if: always()
        run: |
          if [ -f .scratch/blocker.md ]; then
            echo "blocked=true" >> "$GITHUB_OUTPUT"
            echo "Agent reported a blocker:"
            cat .scratch/blocker.md
          else
            echo "blocked=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Report blocker to Dispatch
        if: always() && steps.check-blocker.outputs.blocked == 'true' && env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        run: |
          BLOCKER_PAYLOAD=$(jq -n \
            --arg type "blocker_reported" \
            --rawfile content .scratch/blocker.md \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_url "$GITHUB_RUN_URL" \
            '{type: $type, content: $content, metadata: {run_id: $run_id, run_url: $run_url, workflow_type: "prd_implement"}}')

          curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/activity" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$BLOCKER_PAYLOAD" || echo "Warning: Failed to post blocker (non-fatal)"

          # Extract blocker category from the file
          BLOCKER_CATEGORY=$(grep -oP 'Category:\s*\K\S+' .scratch/blocker.md || echo "unknown")

          BLOCKER_REASON=$(head -5 .scratch/blocker.md | tr '\n' ' ')

          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          STATUS_PAYLOAD=$(jq -n \
            --arg spawn_status "completed" \
            --arg spawn_completed_at "$TIMESTAMP" \
            --arg agent_status "blocked" \
            --arg blocked_reason "$BLOCKER_REASON" \
            '{spawn_status: $spawn_status, spawn_completed_at: $spawn_completed_at, agent_status: $agent_status, blocked_reason: $blocked_reason}')

          curl -sf -X PATCH "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$STATUS_PAYLOAD" || echo "Warning: Failed to update blocker status (non-fatal)"

      - name: Check for fix
        id: check-fix
        if: steps.check-blocker.outputs.blocked != 'true'
        env:
          BRANCH_NAME: ${{ steps.branch.outputs.name }}
          ISSUE_SOURCE: ${{ inputs.source }}
          ISSUE_TITLE: ${{ inputs.title }}
          ISSUE_ID: ${{ inputs.issue_identifier }}
        run: |
          # Check if agent committed changes or left uncommitted work
          HAS_COMMITS=false
          if git log --oneline origin/staging..HEAD 2>/dev/null | grep -q .; then
            HAS_COMMITS=true
          fi

          HAS_UNCOMMITTED=false
          if ! git diff --quiet || ! git diff --cached --quiet; then
            HAS_UNCOMMITTED=true
          fi

          if [ "$HAS_COMMITS" = "false" ] && [ "$HAS_UNCOMMITTED" = "false" ]; then
            echo "fix_attempted=false" >> "$GITHUB_OUTPUT"
            echo "No implementation commits found"
          else
            # Auto-commit any uncommitted changes the agent left behind
            if [ "$HAS_UNCOMMITTED" = "true" ]; then
              echo "Agent left uncommitted changes -- auto-committing"
              git diff --stat
              git add -A
              git reset -- .scratch/ 2>/dev/null || true
              if ! git diff --cached --quiet; then
                SUMMARY=""
                if [ -f .scratch/outcome-summary.txt ]; then
                  SUMMARY=$(head -1 .scratch/outcome-summary.txt)
                fi
                git commit -m "feat($ISSUE_SOURCE): $ISSUE_TITLE [$ISSUE_ID]

$SUMMARY

Co-Authored-By: Claude Code <noreply@anthropic.com>"
              fi
            fi

            # Move commits to a new branch for the PR
            git checkout -b "$BRANCH_NAME"
            echo "fix_attempted=true" >> "$GITHUB_OUTPUT"
            echo "Moved agent changes to branch: $BRANCH_NAME"
          fi

      - name: Push branch and create PR
        id: create-pr
        if: steps.run-result.outputs.pr_needed == 'true' || (steps.check-fix.outputs.fix_attempted == 'true' && steps.run-result.outputs.changes_made == 'true')
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          # Ensure .github/ directory is clean - PAT may lack `workflows` scope
          # which blocks pushing any changes to workflow files.
          git restore .github/ 2>/dev/null || true

          # Use PAT for push (enterprise blocks default GITHUB_TOKEN writes)
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          BRANCH_NAME=$(git branch --show-current)
          git push origin "HEAD:${BRANCH_NAME}"

          DISPATCH_ISSUE_URL="${DISPATCH_API_URL}/issue/${INPUT_ISSUE_IDENTIFIER}"
          {
            if [ -f .scratch/implementation-summary.md ]; then
              cat .scratch/implementation-summary.md
            else
              echo "## What Changed"
              echo ""
              echo "Autonomous implementation for ${INPUT_ISSUE_IDENTIFIER}."
              echo ""
              echo "## Changes"
              echo ""
              git log --oneline staging..HEAD
              echo ""
              echo "## Verification"
              echo ""
              echo "*No structured summary was generated. See workflow logs for details.*"
            fi
            echo ""
            echo "---"
            echo ""
            echo "> Autonomously implemented by Claude Code"
            echo "> **Issue**: [${INPUT_ISSUE_IDENTIFIER} on Dispatch](${DISPATCH_ISSUE_URL}) | **Run**: [Workflow Logs](${GITHUB_RUN_URL})"
          } > .scratch/pr-body.md

          PR_BODY=$(cat .scratch/pr-body.md)

          # Use REST API directly with PAT to bypass enterprise GraphQL restrictions
          PR_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/pulls" \
            -H "Authorization: token ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -d "$(jq -n \
              --arg title "feat: ${INPUT_TITLE} [${INPUT_ISSUE_IDENTIFIER}]" \
              --arg body "$PR_BODY" \
              --arg head "$BRANCH_NAME" \
              --arg base "staging" \
              '{title: $title, body: $body, head: $head, base: $base}')")

          HTTP_CODE=$(echo "$PR_RESPONSE" | tail -1)
          PR_RESPONSE=$(echo "$PR_RESPONSE" | sed '$d')

          PR_URL=$(echo "$PR_RESPONSE" | jq -r '.html_url')

          if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            echo "Failed to create PR (HTTP $HTTP_CODE):"
            echo "$PR_RESPONSE" | jq . 2>/dev/null || echo "$PR_RESPONSE"
            exit 1
          fi

          if [ "$PR_URL" = "null" ] || [ -z "$PR_URL" ]; then
            echo "PR response missing html_url:"
            echo "$PR_RESPONSE" | jq . 2>/dev/null || echo "$PR_RESPONSE"
            exit 1
          fi

          PR_NUMBER=$(echo "$PR_RESPONSE" | jq -r '.number')
          echo "pr_url=${PR_URL}" >> "$GITHUB_OUTPUT"
          echo "pr_number=${PR_NUMBER}" >> "$GITHUB_OUTPUT"
          echo "Created PR: ${PR_URL}"

      - name: Upload screenshots to PR
        if: steps.create-pr.outputs.pr_number != ''
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          PR_NUMBER="${{ steps.create-pr.outputs.pr_number }}"
          SCREENSHOT_DIR=".scratch/screenshots"

          if [ ! -d "$SCREENSHOT_DIR" ] || [ -z "$(ls -A "$SCREENSHOT_DIR" 2>/dev/null)" ]; then
            echo "No screenshots to upload"
            exit 0
          fi

          echo "Uploading screenshots as PR comment..."
          COMMENT="## Screenshots\n\n"

          for img in "$SCREENSHOT_DIR"/*.png "$SCREENSHOT_DIR"/*.jpg; do
            [ -f "$img" ] || continue
            FILENAME=$(basename "$img")

            # Upload image to GitHub via the repo contents API on a special branch
            CONTENT=$(base64 -w0 "$img" 2>/dev/null || base64 "$img")
            UPLOAD_PATH="pr-assets/${PR_NUMBER}/${FILENAME}"

            UPLOAD_RESP=$(curl -s -X PUT \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/contents/${UPLOAD_PATH}" \
              -H "Authorization: token ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -d "$(jq -n \
                --arg message "assets: screenshots for PR #${PR_NUMBER}" \
                --arg content "$CONTENT" \
                --arg branch "staging" \
                '{message: $message, content: $content, branch: $branch}')")

            DOWNLOAD_URL=$(echo "$UPLOAD_RESP" | jq -r '.content.download_url // empty')
            if [ -n "$DOWNLOAD_URL" ]; then
              COMMENT="${COMMENT}### ${FILENAME}\n![${FILENAME}](${DOWNLOAD_URL})\n\n"
            fi
          done

          # Post comment with embedded images
          if [ "$COMMENT" != "## Screenshots\n\n" ]; then
            curl -s -X POST \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
              -H "Authorization: token ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -d "$(jq -n --arg body "$(echo -e "$COMMENT")" '{body: $body}')" || echo "Warning: Failed to post screenshots comment"
          fi

      - name: Post results to Dispatch
        if: always() && steps.check-blocker.outputs.blocked != 'true' && env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        env:
          PR_URL: ${{ steps.create-pr.outputs.pr_url }}
          FIX_ATTEMPTED: ${{ steps.check-fix.outputs.fix_attempted }}
          JOB_STATUS: ${{ job.status }}
          OUTCOME: ${{ steps.run-result.outputs.outcome }}
          PR_NEEDED: ${{ steps.run-result.outputs.pr_needed }}
        run: |
          if [ "$JOB_STATUS" = "success" ]; then
            SPAWN_STATUS="completed"
          else
            SPAWN_STATUS="failed"
          fi

          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          # Build summary from git log or output
          if [ -f .scratch/implementation-summary.md ]; then
            SUMMARY_FILE=".scratch/implementation-summary.md"
          else
            git log --oneline staging..HEAD 2>/dev/null > .scratch/git-summary.md || echo "No commits" > .scratch/git-summary.md
            SUMMARY_FILE=".scratch/git-summary.md"
          fi

          # Read cost data if available
          COST_USD="0"
          NUM_TURNS="0"
          MODEL="unknown"
          if [ -f .scratch/claude-cost.json ]; then
            COST_USD=$(jq -r '.cost_usd // 0' .scratch/claude-cost.json)
            NUM_TURNS=$(jq -r '.num_turns // 0' .scratch/claude-cost.json)
            MODEL=$(jq -r '.model // "unknown"' .scratch/claude-cost.json)
          fi

          # Also check fix session cost if it exists
          if [ -f .scratch/claude-fix-raw.log ]; then
            FIX_COST=$(python3 -c "
          import json
          for line in open('.scratch/claude-fix-raw.log'):
              line = line.strip()
              if not line: continue
              try:
                  event = json.loads(line)
                  if event.get('type') == 'result':
                      print(event.get('total_cost_usd', 0))
                      break
              except: pass
          " 2>/dev/null || echo "0")
            if [ -n "$FIX_COST" ] && [ "$FIX_COST" != "0" ]; then
              COST_USD=$(python3 -c "print(round($COST_USD + $FIX_COST, 4))")
            fi
          fi

          ACTIVITY_PAYLOAD=$(jq -n \
            --arg type "implementation_complete" \
            --rawfile content "$SUMMARY_FILE" \
            --arg pr_url "$PR_URL" \
            --arg fix_attempted "${FIX_ATTEMPTED:-false}" \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_url "$GITHUB_RUN_URL" \
            --arg cost_usd "$COST_USD" \
            --arg num_turns "$NUM_TURNS" \
            --arg model "$MODEL" \
            '{type: $type, content: $content, metadata: {pr_url: $pr_url, fix_attempted: $fix_attempted, run_id: $run_id, run_url: $run_url, workflow_type: "prd_implement", cost_usd: $cost_usd, num_turns: $num_turns, model: $model}}')

          curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/activity" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$ACTIVITY_PAYLOAD" || echo "Warning: Failed to post activity (non-fatal)"

          # Read outcome summary from file (avoids quoting issues)
          OUTCOME_SUMMARY=""
          if [ -f .scratch/outcome-summary.txt ]; then
            OUTCOME_SUMMARY=$(cat .scratch/outcome-summary.txt)
          fi

          # Transition issue status after implementation:
          # - PR created → "In Review" (code needs human review)
          # - No PR but completed → "In Review" (outcome needs human review)
          # - Failed → leave status for auto-transition in API route
          ISSUE_STATUS=""
          if [ "$SPAWN_STATUS" = "completed" ]; then
            ISSUE_STATUS="In Review"
          fi

          STATUS_PAYLOAD=$(jq -n \
            --arg spawn_status "$SPAWN_STATUS" \
            --arg spawn_completed_at "$TIMESTAMP" \
            --arg cost_usd "$COST_USD" \
            --arg num_turns "$NUM_TURNS" \
            --arg model "$MODEL" \
            --arg run_outcome "${OUTCOME:-failed}" \
            --arg outcome_summary "$OUTCOME_SUMMARY" \
            --arg status "$ISSUE_STATUS" \
            '{spawn_status: $spawn_status, spawn_completed_at: $spawn_completed_at, cost_usd: $cost_usd, num_turns: $num_turns, model: $model, run_outcome: $run_outcome, outcome_summary: $outcome_summary} + (if $status != "" then {status: $status} else {} end)')

          curl -sf -X PATCH "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$STATUS_PAYLOAD" || echo "Warning: Failed to update spawn status (non-fatal)"

          # Update agent run record via /runs/current
          [ -f .scratch/implementation-prompt.md ] || echo "" > .scratch/implementation-prompt.md
          [ -f .scratch/claude-output.log ] || echo "" > .scratch/claude-output.log
          REPORT_FILE=".scratch/implementation-summary.md"
          [ -f "$REPORT_FILE" ] || echo "" > "$REPORT_FILE"

          PR_NUMBER=""
          if [ -n "${PR_URL:-}" ]; then
            PR_NUMBER=$(echo "$PR_URL" | grep -o '[0-9]*$')
          fi

          RUN_UPDATE=$(jq -n \
            --arg status "$SPAWN_STATUS" \
            --arg outcome "${OUTCOME:-failed}" \
            --arg outcome_summary "${OUTCOME_SUMMARY:-}" \
            --arg cost_usd "${COST_USD:-0}" \
            --arg num_turns "${NUM_TURNS:-0}" \
            --arg model "${MODEL:-unknown}" \
            --arg pr_number "$PR_NUMBER" \
            --rawfile prompt_text .scratch/implementation-prompt.md \
            --rawfile transcript .scratch/claude-output.log \
            --rawfile report_content "$REPORT_FILE" \
            '{status: $status, outcome: $outcome, outcome_summary: $outcome_summary, cost_usd: ($cost_usd | tonumber), num_turns: ($num_turns | tonumber), model: $model, prompt_text: $prompt_text, transcript: $transcript, report_content: $report_content} + (if $pr_number != "" then {pr_number: ($pr_number | tonumber)} else {} end)')

          curl -sf -X PATCH "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/runs/current" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$RUN_UPDATE" || echo "Warning: Failed to update run record (non-fatal)"

      - name: Upload full agent log
        if: always() && env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        run: |
          LOG_FILE=".scratch/claude-output.log"
          if [ ! -f "$LOG_FILE" ]; then
            echo "No output log found, skipping"
            exit 0
          fi

          FULL_SIZE=$(wc -c < "$LOG_FILE")

          # Truncate to ~500KB to stay within reasonable API limits
          head -c 512000 "$LOG_FILE" > .scratch/full-log-truncated.txt
          if [ "$FULL_SIZE" -gt 512000 ]; then
            echo "" >> .scratch/full-log-truncated.txt
            echo "... [truncated - full log was $(( FULL_SIZE / 1024 ))KB]" >> .scratch/full-log-truncated.txt
          fi

          # Use --rawfile to avoid bash quoting issues with arbitrary log content
          jq -n \
            --arg type "agent_full_log" \
            --rawfile content .scratch/full-log-truncated.txt \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_url "$GITHUB_RUN_URL" \
            '{type: $type, content: $content, metadata: {run_id: $run_id, run_url: $run_url, workflow_type: "prd_implement"}}' \
            > .scratch/full-log-payload.json

          curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/activity" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @.scratch/full-log-payload.json || echo "Warning: Failed to upload full log (non-fatal)"

          echo "Full log uploaded ($(( FULL_SIZE / 1024 ))KB)"

      - name: Report failure
        if: failure() && steps.check-blocker.outputs.blocked != 'true' && env.DISPATCH_API_URL != '' && env.DISPATCH_API_KEY != ''
        run: |
          ERROR_TAIL=""
          if [ -f .scratch/claude-output.log ]; then
            ERROR_TAIL=$(tail -20 .scratch/claude-output.log)
          fi

          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          FAILURE_PAYLOAD=$(jq -n \
            --arg type "implementation_failed" \
            --arg content "PRD implementation workflow failed." \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_url "$GITHUB_RUN_URL" \
            --arg error_tail "$ERROR_TAIL" \
            '{type: $type, content: $content, metadata: {run_id: $run_id, run_url: $run_url, error_tail: $error_tail}}')

          curl -sf -X POST "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}/activity" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$FAILURE_PAYLOAD" || true

          STATUS_PAYLOAD=$(jq -n \
            --arg spawn_status "failed" \
            --arg spawn_completed_at "$TIMESTAMP" \
            --arg agent_status "idle" \
            '{spawn_status: $spawn_status, spawn_completed_at: $spawn_completed_at, agent_status: $agent_status}')

          curl -sf -X PATCH "${DISPATCH_API_URL}/api/issues/${INPUT_ISSUE_ID}" \
            -H "Authorization: Bearer ${DISPATCH_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$STATUS_PAYLOAD" || true
