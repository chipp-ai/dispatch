name: PRD Implementation

on:
  workflow_dispatch:
    inputs:
      issue_id:
        description: "Chipp Issues issue ID"
        required: true
        type: string
      issue_identifier:
        description: "Human-readable identifier (e.g. CHIPP-456)"
        required: true
        type: string
      title:
        description: "Issue title / PRD summary"
        required: true
        type: string
      description:
        description: "Full PRD or feature description (markdown)"
        required: true
        type: string
      plan_content:
        description: "Approved implementation plan (markdown)"
        required: true
        type: string

# Only one implementation per issue at a time
concurrency:
  group: prd-implement-${{ inputs.issue_identifier }}
  cancel-in-progress: false

jobs:
  implement:
    name: Implement ${{ inputs.issue_identifier }}
    runs-on: ubuntu-latest
    timeout-minutes: 60

    permissions:
      contents: write
      pull-requests: write

    # SECURITY: All user-provided inputs are passed through env vars to
    # prevent command injection. They are NEVER interpolated in run: blocks.
    # See: https://github.blog/security/vulnerability-research/how-to-catch-github-actions-workflow-injections-before-attackers-do/
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      CHIPP_ISSUES_API_URL: ${{ secrets.CHIPP_ISSUES_API_URL }}
      CHIPP_ISSUES_API_KEY: ${{ secrets.CHIPP_ISSUES_API_KEY }}
      DENO_NO_PACKAGE_JSON: "1"
      INPUT_ISSUE_ID: ${{ inputs.issue_id }}
      INPUT_ISSUE_IDENTIFIER: ${{ inputs.issue_identifier }}
      INPUT_TITLE: ${{ inputs.title }}
      INPUT_DESCRIPTION: ${{ inputs.description }}
      INPUT_PLAN_CONTENT: ${{ inputs.plan_content }}
      GITHUB_RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

    services:
      postgres:
        image: pgvector/pgvector:pg16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: chipp_deno
        ports:
          - 5436:5432
        options: >-
          --health-cmd "pg_isready -U postgres"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout staging
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0

      - name: Setup Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Install MCP browser-devtools dependencies
        run: cd tools/mcp-browser-devtools && npm ci

      - name: Configure CI MCP servers
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/chipp_deno
        run: |
          # Override .mcp.json with CI-appropriate servers (browser + database only)
          cat > .mcp.json << 'MCPEOF'
          {
            "mcpServers": {
              "browser-devtools": {
                "type": "stdio",
                "command": "node",
                "args": ["tools/mcp-browser-devtools/index.js"],
                "env": {
                  "CDP_HOST": "localhost",
                  "CDP_PORT": "9222"
                }
              },
              "chipp-database": {
                "type": "stdio",
                "command": "deno",
                "args": ["run", "--allow-net", "--allow-env", "--allow-read", "tools/mcp-database/index.ts"],
                "env": {
                  "DATABASE_URL": "postgresql://postgres:postgres@localhost:5436/chipp_deno"
                }
              }
            }
          }
          MCPEOF

      - name: Sanitize branch name
        id: branch
        run: |
          SAFE_ID=$(echo "$INPUT_ISSUE_IDENTIFIER" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/-\+/-/g' | sed 's/^-//;s/-$//')
          echo "name=feat/${SAFE_ID}" >> "$GITHUB_OUTPUT"
          echo "Branch name: feat/${SAFE_ID}"

      - name: Notify Chipp Issues - Implementing
        if: env.CHIPP_ISSUES_API_URL != '' && env.CHIPP_ISSUES_API_KEY != ''
        run: |
          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          PAYLOAD=$(jq -n \
            --arg spawn_status "running" \
            --arg spawn_run_id "$GITHUB_RUN_ID" \
            --arg spawn_started_at "$TIMESTAMP" \
            --arg agent_status "implementing" \
            --arg spawn_type "implement" \
            '{spawn_status: $spawn_status, spawn_run_id: $spawn_run_id, spawn_started_at: $spawn_started_at, agent_status: $agent_status, spawn_type: $spawn_type}')

          curl -sf -X PATCH "${CHIPP_ISSUES_API_URL}/api/issues/${INPUT_ISSUE_ID}" \
            -H "Authorization: Bearer ${CHIPP_ISSUES_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" || echo "Warning: Failed to notify Chipp Issues (non-fatal)"

      - name: Setup database
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/chipp_deno
        run: |
          # Run migrations to set up the schema
          deno task db:migrate || echo "Warning: Migration failed (may need manual schema setup)"

      - name: Seed test data
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/chipp_deno
        run: |
          psql "$DATABASE_URL" -f scripts/seed-test-data.sql

      - name: Install web dependencies
        run: cd web && npm ci

      - name: Start dev servers
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/chipp_deno
          NODE_ENV: development
          PORT: "8000"
        run: |
          mkdir -p .scratch/logs

          # Start Deno API server (with --watch so it picks up Claude's changes)
          deno task dev > .scratch/logs/api-server.log 2>&1 &
          echo "API server started (PID: $!)"

          # Start Vite dev server (use absolute path for log since we cd)
          LOGDIR="$(pwd)/.scratch/logs"
          (cd web && npm run dev > "$LOGDIR/vite-server.log" 2>&1) &
          echo "Vite server started (PID: $!)"

          # Health check API server (wait up to 30s)
          echo "Waiting for API server at localhost:8000..."
          for i in $(seq 1 30); do
            if curl -sf http://localhost:8000/health > /dev/null 2>&1; then
              echo "API server ready after ${i}s"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "WARNING: API server not responding after 30s"
              cat .scratch/logs/api-server.log 2>/dev/null || echo "(no log file)"
            fi
            sleep 1
          done

          # Health check Vite server (wait up to 30s)
          echo "Waiting for Vite server at localhost:5173..."
          for i in $(seq 1 30); do
            if curl -sf http://localhost:5173 > /dev/null 2>&1; then
              echo "Vite server ready after ${i}s"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "WARNING: Vite server not responding after 30s"
              cat .scratch/logs/vite-server.log 2>/dev/null || echo "(no log file)"
            fi
            sleep 1
          done

          echo "Dev servers are running."

      - name: Start Chrome for browser testing
        run: |
          # Chrome is pre-installed on ubuntu-latest; start after dev servers are up
          google-chrome --headless --no-sandbox --disable-gpu \
            --remote-debugging-port=9222 \
            --remote-debugging-address=127.0.0.1 \
            about:blank &
          sleep 2
          # Verify Chrome DevTools Protocol is accessible
          curl -sf http://localhost:9222/json/version && echo "Chrome DevTools ready" || echo "WARNING: Chrome DevTools not responding"

      - name: Build implementation prompt
        run: |
          mkdir -p .scratch

          # Build prompt file using jq for safe string handling (no shell interpolation of inputs)
          jq -n \
            --arg identifier "$INPUT_ISSUE_IDENTIFIER" \
            --arg title "$INPUT_TITLE" \
            --arg description "$INPUT_DESCRIPTION" \
            --arg plan "$INPUT_PLAN_CONTENT" \
            '{identifier: $identifier, title: $title, description: $description, plan: $plan}' \
            > .scratch/prompt-data.json

          python3 -c "
          import json, sys
          d = json.load(open('.scratch/prompt-data.json'))
          prompt = f\"\"\"You are autonomously implementing an approved feature plan for the chipp-deno project.
          You MUST follow the approved plan closely. Do NOT deviate from it without good reason.

          Issue: {d['identifier']} - {d['title']}

          Description / PRD:
          {d['description']}

          APPROVED IMPLEMENTATION PLAN:
          {d['plan']}

          RUNNING ENVIRONMENT:
          A full-stack dev environment is running and available:
          - API server: http://localhost:8000 (Deno with --watch, auto-reloads on file changes)
          - Frontend: http://localhost:5173 (Vite dev server, hot module reload)
          - Database: postgresql://postgres:postgres@localhost:5436/chipp_deno (seeded with test data)
          - Chrome: headless Chrome with DevTools Protocol on port 9222
          - Server logs: .scratch/logs/api-server.log and .scratch/logs/vite-server.log

          BROWSER TESTING (MCP tools available):
          You have access to browser-devtools MCP tools for interacting with Chrome.
          Use these tools -- do NOT write puppeteer scripts:
          - mcp__browser-devtools__browser_navigate: Navigate to a URL
          - mcp__browser-devtools__browser_take_screenshot: Take a screenshot (saves to .scratch/screenshots/)
          - mcp__browser-devtools__browser_click: Click elements by CSS selector or text
          - mcp__browser-devtools__browser_type: Type into input fields
          - mcp__browser-devtools__browser_get_element: Inspect element text/attributes
          - mcp__browser-devtools__browser_wait_for: Wait for elements to appear
          - mcp__browser-devtools__browser_get_console_logs: Check for console errors
          - mcp__browser-devtools__browser_get_network_requests: Check API calls
          - mcp__browser-devtools__browser_execute_js: Run JS in the browser context
          Use these to verify your implementation works visually before committing.

          DATABASE (MCP tools available):
          You have access to chipp-database MCP tools:
          - mcp__chipp-database__db_query: Run SELECT queries
          - mcp__chipp-database__db_execute: Run INSERT/UPDATE/DELETE
          - mcp__chipp-database__db_list_tables: List tables
          - mcp__chipp-database__db_describe_table: Show table schema
          Use these to verify database changes work correctly.

          Test data in the database:
          - Organization: id=11111111-1111-1111-1111-111111111111, name='Test Organization'
          - User: id=22222222-2222-2222-2222-222222222222, email='test-developer@example.com'
          - Application: id=00000000-0000-0000-0000-000000000003, app_name_id='test-chat-app'
          - Consumer: id=44444444-4444-4444-4444-444444444444, email='test-consumer@example.com'
          - Session: id=00000000-0000-0000-0000-000000000005 (valid for 30 days)

          Instructions:
          1. Read CLAUDE.md first to understand the codebase conventions
          2. Create a feature branch: git checkout -b feat/{d['identifier'].lower().replace(' ', '-')}
          3. Follow the plan step by step:
             - Create files listed in 'Files to Create'
             - Modify files listed in 'Files to Modify'
             - Create database migrations if listed in 'Database Changes'
             - Follow existing code patterns and conventions
          4. After implementing, you MUST verify your work by running the FULL PR check suite.
             These are the exact checks that will run on your PR -- ALL must pass:
             a. deno check main.ts          (type checking)
             b. deno lint                    (linting -- covers src/ AND dispatch/)
             c. deno test --allow-net --allow-env --allow-read --allow-write --allow-ffi src/__tests__/llm/normalization/ src/__tests__/llm/normalize_history_test.ts
             d. cd web && npm run check && npm run build  (Svelte type check + build -- npm ci already done)
             If ANY check fails, fix the issue and re-run ALL checks until they pass.
             Fix pre-existing failures too -- the PR must be green.
          5. Commit your changes with a descriptive message referencing {d['identifier']}
          6. Do NOT push branches - just prepare commits locally

          EVIDENCE & PR SUMMARY (MANDATORY):
          After ALL implementation and checks pass, you MUST write .scratch/implementation-summary.md.
          This file becomes the PR description that humans review. Use this exact format:

          ```markdown
          ## What Changed
          <2-4 sentence summary of what this PR does and why>

          ## Changes
          | File | Change |
          |------|--------|
          | path/to/file.ts | Description of what changed |
          | ... | ... |

          ## How It Works
          <Brief technical explanation of the approach taken, key design decisions,
          and how this fits into the existing architecture. 3-5 sentences.>

          ## Verification

          ### PR Checks
          - [ ] `deno check main.ts` -- pass/fail
          - [ ] `deno lint` -- pass/fail
          - [ ] `deno test` -- pass/fail
          - [ ] `svelte build` -- pass/fail

          ### Evidence
          <This section depends on the type of change:>

          FOR UI CHANGES (MANDATORY SCREENSHOTS):
          Use the browser-devtools MCP tools to test and screenshot your changes:
          1. Navigate to the changed page: mcp__browser-devtools__browser_navigate
          2. Interact with UI elements: browser_click, browser_type, browser_wait_for
          3. Take screenshots: mcp__browser-devtools__browser_take_screenshot
          4. Check for console errors: mcp__browser-devtools__browser_get_console_logs
          Save screenshots to .scratch/screenshots/ and reference them in the summary.
          You MUST take at least one screenshot for any change that affects the UI.

          FOR DATABASE CHANGES: Use the chipp-database MCP tools:
          1. Run the migration: deno task db:migrate
          2. Verify with mcp__chipp-database__db_query or db_describe_table
          Paste the query results in the summary as proof.

          FOR API CHANGES: The API server is running at http://localhost:8000.
          Use curl to hit the actual running endpoints and paste the responses.
          Also check browser_get_network_requests if the UI calls these endpoints.

          FOR LOGIC/REFACTOR CHANGES: Show before/after code snippets or test output
          that proves the change works correctly.

          ## Potential Risks
          <List anything a reviewer should pay attention to: breaking changes,
          performance implications, security considerations, edge cases. Say "None identified" if none.>
          ```

          CRITICAL STOP CONDITIONS:
          If you encounter ANY of the following, STOP IMMEDIATELY:
          - Missing environment variables or secrets that you cannot create
          - Requirements that are unclear or contradictory
          - Dependencies that are not available or cannot be installed
          - Test failures that indicate a fundamental design issue
          - Design decisions that are not covered by the plan
          - Work that is clearly out of scope of the plan

          When you must STOP:
          1. Write a detailed explanation to .scratch/blocker.md with:
             - Category: missing_env | unclear_requirement | missing_dependency | test_failure | design_decision | out_of_scope
             - What you were trying to do
             - What went wrong
             - What information or decision you need from a human
          2. Exit immediately after writing the blocker file

          IMPORTANT: Working around blockers instead of reporting them is a FAILURE.
          It is better to stop and ask for help than to produce incorrect or incomplete work.
          \"\"\"
          with open('.scratch/implementation-prompt.md', 'w') as f:
              f.write(prompt)
          "

      - name: Run Implementation
        id: implement
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/chipp_deno
          BRANCH_NAME: ${{ steps.branch.outputs.name }}
        run: |
          mkdir -p .scratch/screenshots

          # Create a stream-json to human-readable filter script
          cat > .scratch/stream-filter.py << 'PYEOF'
          import sys, json
          for line in sys.stdin:
              line = line.strip()
              if not line:
                  continue
              try:
                  event = json.loads(line)
                  t = event.get("type", "")
                  if t == "assistant":
                      msg = event.get("message", {})
                      for c in msg.get("content", []):
                          if c.get("type") == "text" and c.get("text"):
                              print(c["text"], flush=True)
                          elif c.get("type") == "tool_use":
                              name = c.get("name", "unknown")
                              inp = c.get("input", {})
                              # Show a compact summary of tool calls
                              summary_parts = []
                              for k, v in list(inp.items())[:3]:
                                  val = str(v)[:80]
                                  summary_parts.append(f"{k}={val}")
                              summary = ", ".join(summary_parts)
                              print(f"[TOOL] {name}({summary})", flush=True)
                  elif t == "tool_result":
                      # Show brief tool result (truncated)
                      content = event.get("content", "")
                      if isinstance(content, list):
                          content = " ".join(c.get("text", "") for c in content if isinstance(c, dict))
                      preview = str(content)[:200]
                      if len(str(content)) > 200:
                          preview += "..."
                      print(f"[RESULT] {preview}", flush=True)
                  elif t == "result":
                      cost = event.get("total_cost_usd", 0)
                      turns = event.get("num_turns", 0)
                      print(f"\n[COMPLETED] Cost: ${cost:.2f}, Turns: {turns}", flush=True)
              except (json.JSONDecodeError, KeyError):
                  # Not JSON or unexpected format - print as-is
                  print(line, flush=True)
          PYEOF

          # Background heartbeat: tail the human-readable log and post progress every 60s
          if [ -n "$CHIPP_ISSUES_API_URL" ] && [ -n "$CHIPP_ISSUES_API_KEY" ]; then
            (
              PREV_HASH=""
              while true; do
                sleep 60
                [ -f .scratch/claude-output.log ] || continue
                LAST_LINES=$(tail -30 .scratch/claude-output.log 2>/dev/null)
                [ -z "$LAST_LINES" ] && continue
                CURR_HASH=$(echo "$LAST_LINES" | md5sum | cut -d' ' -f1)
                [ "$CURR_HASH" = "$PREV_HASH" ] && continue
                PREV_HASH="$CURR_HASH"
                curl -sf -X POST "${CHIPP_ISSUES_API_URL}/api/issues/${INPUT_ISSUE_ID}/activity" \
                  -H "Authorization: Bearer ${CHIPP_ISSUES_API_KEY}" \
                  -H "Content-Type: application/json" \
                  -d "$(jq -n --arg type "agent_heartbeat" --arg content "$LAST_LINES" \
                    '{type: $type, content: $content, metadata: {workflow_type: "prd_implement"}}')" || true
              done
            ) &
            HEARTBEAT_PID=$!
            echo "Heartbeat process started (PID: $HEARTBEAT_PID)"
          fi

          PROMPT=$(cat .scratch/implementation-prompt.md)

          # Use stream-json for real-time output (--print text mode buffers everything)
          # Raw JSON -> tee to raw log -> filter to readable text -> tee to readable log + stdout
          claude --print --verbose --output-format stream-json --dangerously-skip-permissions \
            --mcp-config .mcp.json "$PROMPT" 2>&1 \
            | tee .scratch/claude-raw.log \
            | python3 .scratch/stream-filter.py \
            | tee .scratch/claude-output.log

          # Stop heartbeat when Claude finishes
          [ -n "${HEARTBEAT_PID:-}" ] && kill $HEARTBEAT_PID 2>/dev/null || true

      - name: Verify PR checks pass
        id: verify
        if: success()
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/chipp_deno
        run: |
          echo "Running PR check suite to verify implementation..."
          FAILURES=""

          echo "=== deno check main.ts ==="
          if ! deno check main.ts 2>&1 | tee .scratch/verify-typecheck.log; then
            FAILURES="${FAILURES}deno-check "
          fi

          echo "=== deno lint ==="
          if ! deno lint 2>&1 | tee .scratch/verify-lint.log; then
            FAILURES="${FAILURES}deno-lint "
          fi

          echo "=== deno test ==="
          if ! deno test --allow-net --allow-env --allow-read --allow-write --allow-ffi \
            src/__tests__/llm/normalization/ \
            src/__tests__/llm/normalize_history_test.ts 2>&1 | tee .scratch/verify-test.log; then
            FAILURES="${FAILURES}deno-test "
          fi

          echo "=== svelte build ==="
          if ! (cd web && npm run check && npm run build) 2>&1 | tee .scratch/verify-svelte.log; then
            FAILURES="${FAILURES}svelte-build "
          fi

          if [ -n "$FAILURES" ]; then
            echo "FAILED CHECKS: $FAILURES"
            echo "checks_failed=true" >> "$GITHUB_OUTPUT"
            echo "$FAILURES" > .scratch/failed-checks.txt
          else
            echo "All PR checks passed!"
            echo "checks_failed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Fix failing checks
        if: steps.verify.outputs.checks_failed == 'true'
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/chipp_deno
        run: |
          FAILURES=$(cat .scratch/failed-checks.txt)
          FIX_PROMPT="The implementation is complete but the following PR checks are failing: ${FAILURES}

          Fix ALL failing checks. Here are the logs:

          $([ -f .scratch/verify-typecheck.log ] && echo '--- deno check ---' && tail -30 .scratch/verify-typecheck.log)
          $([ -f .scratch/verify-lint.log ] && echo '--- deno lint ---' && tail -50 .scratch/verify-lint.log)
          $([ -f .scratch/verify-test.log ] && echo '--- deno test ---' && tail -30 .scratch/verify-test.log)
          $([ -f .scratch/verify-svelte.log ] && echo '--- svelte build ---' && tail -30 .scratch/verify-svelte.log)

          Fix every error, even pre-existing ones. The PR must pass all checks.
          After fixing, commit with a message like 'fix: resolve PR check failures for ISSUE_ID'.
          Do NOT push."

          claude --print --verbose --output-format stream-json --dangerously-skip-permissions \
            --mcp-config .mcp.json "$FIX_PROMPT" 2>&1 \
            | tee -a .scratch/claude-raw.log \
            | python3 .scratch/stream-filter.py \
            | tee -a .scratch/claude-output.log

      - name: Re-verify after fix
        if: steps.verify.outputs.checks_failed == 'true'
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5436/chipp_deno
        run: |
          echo "Re-running PR check suite after fix attempt..."
          STILL_FAILING=""

          deno check main.ts 2>&1 || STILL_FAILING="${STILL_FAILING}deno-check "
          deno lint 2>&1 || STILL_FAILING="${STILL_FAILING}deno-lint "
          deno test --allow-net --allow-env --allow-read --allow-write --allow-ffi \
            src/__tests__/llm/normalization/ \
            src/__tests__/llm/normalize_history_test.ts 2>&1 || STILL_FAILING="${STILL_FAILING}deno-test "
          (cd web && npm run check && npm run build) 2>&1 || STILL_FAILING="${STILL_FAILING}svelte-build "

          if [ -n "$STILL_FAILING" ]; then
            echo "WARNING: Still failing after fix: $STILL_FAILING"
            echo "Proceeding anyway - PR will show failures for human review."
          else
            echo "All checks pass after fix!"
          fi

      - name: Check for blocker
        id: check-blocker
        if: always()
        run: |
          if [ -f .scratch/blocker.md ]; then
            echo "blocked=true" >> "$GITHUB_OUTPUT"
            echo "Agent reported a blocker:"
            cat .scratch/blocker.md
          else
            echo "blocked=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Report blocker to Chipp Issues
        if: always() && steps.check-blocker.outputs.blocked == 'true' && env.CHIPP_ISSUES_API_URL != '' && env.CHIPP_ISSUES_API_KEY != ''
        run: |
          BLOCKER_PAYLOAD=$(jq -n \
            --arg type "blocker_reported" \
            --rawfile content .scratch/blocker.md \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_url "$GITHUB_RUN_URL" \
            '{type: $type, content: $content, metadata: {run_id: $run_id, run_url: $run_url, workflow_type: "prd_implement"}}')

          curl -sf -X POST "${CHIPP_ISSUES_API_URL}/api/issues/${INPUT_ISSUE_ID}/activity" \
            -H "Authorization: Bearer ${CHIPP_ISSUES_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$BLOCKER_PAYLOAD" || echo "Warning: Failed to post blocker (non-fatal)"

          # Extract blocker category from the file
          BLOCKER_CATEGORY=$(grep -oP 'Category:\s*\K\S+' .scratch/blocker.md || echo "unknown")

          BLOCKER_REASON=$(head -5 .scratch/blocker.md | tr '\n' ' ')

          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          STATUS_PAYLOAD=$(jq -n \
            --arg spawn_status "completed" \
            --arg spawn_completed_at "$TIMESTAMP" \
            --arg agent_status "blocked" \
            --arg blocked_reason "$BLOCKER_REASON" \
            '{spawn_status: $spawn_status, spawn_completed_at: $spawn_completed_at, agent_status: $agent_status, blocked_reason: $blocked_reason}')

          curl -sf -X PATCH "${CHIPP_ISSUES_API_URL}/api/issues/${INPUT_ISSUE_ID}" \
            -H "Authorization: Bearer ${CHIPP_ISSUES_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$STATUS_PAYLOAD" || echo "Warning: Failed to update blocker status (non-fatal)"

      - name: Check for fix
        id: check-fix
        if: steps.check-blocker.outputs.blocked != 'true'
        run: |
          CURRENT_BRANCH=$(git branch --show-current)
          if [ "$CURRENT_BRANCH" != "staging" ] && git log --oneline staging..HEAD 2>/dev/null | grep -q .; then
            echo "fix_attempted=true" >> "$GITHUB_OUTPUT"
            echo "Implementation committed on branch: $CURRENT_BRANCH"
          elif git diff --quiet && git diff --cached --quiet; then
            echo "fix_attempted=false" >> "$GITHUB_OUTPUT"
            echo "No implementation commits found"
          else
            echo "fix_attempted=false" >> "$GITHUB_OUTPUT"
            echo "Warning: uncommitted changes found but no commit was made"
            git diff --stat
          fi

      - name: Push branch and create PR
        id: create-pr
        if: steps.check-fix.outputs.fix_attempted == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          # Use PAT for push (enterprise blocks default GITHUB_TOKEN writes)
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
          BRANCH_NAME=$(git branch --show-current)
          git push origin "HEAD:${BRANCH_NAME}"

          {
            if [ -f .scratch/implementation-summary.md ]; then
              cat .scratch/implementation-summary.md
            else
              echo "## What Changed"
              echo ""
              echo "Autonomous implementation for ${INPUT_ISSUE_IDENTIFIER}."
              echo ""
              echo "## Changes"
              echo ""
              git log --oneline staging..HEAD
              echo ""
              echo "## Verification"
              echo ""
              echo "*No structured summary was generated. See workflow logs for details.*"
            fi
            echo ""
            echo "---"
            echo ""
            echo "> Autonomously implemented by Claude Code"
            echo "> **Issue**: ${INPUT_ISSUE_IDENTIFIER} | **Run**: [Workflow Logs](${GITHUB_RUN_URL})"
          } > .scratch/pr-body.md

          PR_BODY=$(cat .scratch/pr-body.md)

          # Use REST API directly with PAT to bypass enterprise GraphQL restrictions
          PR_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/pulls" \
            -H "Authorization: token ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -d "$(jq -n \
              --arg title "feat: ${INPUT_TITLE} [${INPUT_ISSUE_IDENTIFIER}]" \
              --arg body "$PR_BODY" \
              --arg head "$BRANCH_NAME" \
              --arg base "staging" \
              '{title: $title, body: $body, head: $head, base: $base}')")

          HTTP_CODE=$(echo "$PR_RESPONSE" | tail -1)
          PR_RESPONSE=$(echo "$PR_RESPONSE" | sed '$d')

          PR_URL=$(echo "$PR_RESPONSE" | jq -r '.html_url')

          if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            echo "Failed to create PR (HTTP $HTTP_CODE):"
            echo "$PR_RESPONSE" | jq . 2>/dev/null || echo "$PR_RESPONSE"
            exit 1
          fi

          if [ "$PR_URL" = "null" ] || [ -z "$PR_URL" ]; then
            echo "PR response missing html_url:"
            echo "$PR_RESPONSE" | jq . 2>/dev/null || echo "$PR_RESPONSE"
            exit 1
          fi

          PR_NUMBER=$(echo "$PR_RESPONSE" | jq -r '.number')
          echo "pr_url=${PR_URL}" >> "$GITHUB_OUTPUT"
          echo "pr_number=${PR_NUMBER}" >> "$GITHUB_OUTPUT"
          echo "Created PR: ${PR_URL}"

      - name: Upload screenshots to PR
        if: steps.create-pr.outputs.pr_number != ''
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          PR_NUMBER="${{ steps.create-pr.outputs.pr_number }}"
          SCREENSHOT_DIR=".scratch/screenshots"

          if [ ! -d "$SCREENSHOT_DIR" ] || [ -z "$(ls -A "$SCREENSHOT_DIR" 2>/dev/null)" ]; then
            echo "No screenshots to upload"
            exit 0
          fi

          echo "Uploading screenshots as PR comment..."
          COMMENT="## Screenshots\n\n"

          for img in "$SCREENSHOT_DIR"/*.png "$SCREENSHOT_DIR"/*.jpg; do
            [ -f "$img" ] || continue
            FILENAME=$(basename "$img")

            # Upload image to GitHub via the repo contents API on a special branch
            CONTENT=$(base64 -w0 "$img" 2>/dev/null || base64 "$img")
            UPLOAD_PATH="pr-assets/${PR_NUMBER}/${FILENAME}"

            UPLOAD_RESP=$(curl -s -X PUT \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/contents/${UPLOAD_PATH}" \
              -H "Authorization: token ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -d "$(jq -n \
                --arg message "assets: screenshots for PR #${PR_NUMBER}" \
                --arg content "$CONTENT" \
                --arg branch "staging" \
                '{message: $message, content: $content, branch: $branch}')")

            DOWNLOAD_URL=$(echo "$UPLOAD_RESP" | jq -r '.content.download_url // empty')
            if [ -n "$DOWNLOAD_URL" ]; then
              COMMENT="${COMMENT}### ${FILENAME}\n![${FILENAME}](${DOWNLOAD_URL})\n\n"
            fi
          done

          # Post comment with embedded images
          if [ "$COMMENT" != "## Screenshots\n\n" ]; then
            curl -s -X POST \
              "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUMBER}/comments" \
              -H "Authorization: token ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -d "$(jq -n --arg body "$(echo -e "$COMMENT")" '{body: $body}')" || echo "Warning: Failed to post screenshots comment"
          fi

      - name: Post results to Chipp Issues
        if: always() && steps.check-blocker.outputs.blocked != 'true' && env.CHIPP_ISSUES_API_URL != '' && env.CHIPP_ISSUES_API_KEY != ''
        env:
          PR_URL: ${{ steps.create-pr.outputs.pr_url }}
          FIX_ATTEMPTED: ${{ steps.check-fix.outputs.fix_attempted }}
          JOB_STATUS: ${{ job.status }}
        run: |
          if [ "$JOB_STATUS" = "success" ]; then
            SPAWN_STATUS="completed"
          else
            SPAWN_STATUS="failed"
          fi

          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          # Build summary from git log or output
          if [ -f .scratch/implementation-summary.md ]; then
            SUMMARY_FILE=".scratch/implementation-summary.md"
          else
            git log --oneline staging..HEAD 2>/dev/null > .scratch/git-summary.md || echo "No commits" > .scratch/git-summary.md
            SUMMARY_FILE=".scratch/git-summary.md"
          fi

          ACTIVITY_PAYLOAD=$(jq -n \
            --arg type "implementation_complete" \
            --rawfile content "$SUMMARY_FILE" \
            --arg pr_url "$PR_URL" \
            --arg fix_attempted "${FIX_ATTEMPTED:-false}" \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_url "$GITHUB_RUN_URL" \
            '{type: $type, content: $content, metadata: {pr_url: $pr_url, fix_attempted: $fix_attempted, run_id: $run_id, run_url: $run_url, workflow_type: "prd_implement"}}')

          curl -sf -X POST "${CHIPP_ISSUES_API_URL}/api/issues/${INPUT_ISSUE_ID}/activity" \
            -H "Authorization: Bearer ${CHIPP_ISSUES_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$ACTIVITY_PAYLOAD" || echo "Warning: Failed to post activity (non-fatal)"

          STATUS_PAYLOAD=$(jq -n \
            --arg spawn_status "$SPAWN_STATUS" \
            --arg spawn_completed_at "$TIMESTAMP" \
            '{spawn_status: $spawn_status, spawn_completed_at: $spawn_completed_at}')

          curl -sf -X PATCH "${CHIPP_ISSUES_API_URL}/api/issues/${INPUT_ISSUE_ID}" \
            -H "Authorization: Bearer ${CHIPP_ISSUES_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$STATUS_PAYLOAD" || echo "Warning: Failed to update spawn status (non-fatal)"

      - name: Upload full agent log
        if: always() && env.CHIPP_ISSUES_API_URL != '' && env.CHIPP_ISSUES_API_KEY != ''
        run: |
          LOG_FILE=".scratch/claude-output.log"
          if [ ! -f "$LOG_FILE" ]; then
            echo "No output log found, skipping"
            exit 0
          fi

          # Truncate to ~500KB to stay within reasonable API limits
          LOG_CONTENT=$(head -c 512000 "$LOG_FILE")
          FULL_SIZE=$(wc -c < "$LOG_FILE")
          if [ "$FULL_SIZE" -gt 512000 ]; then
            LOG_CONTENT="${LOG_CONTENT}

... [truncated - full log was $(( FULL_SIZE / 1024 ))KB]"
          fi

          # Post the full log as an agent_full_log activity
          jq -n \
            --arg type "agent_full_log" \
            --arg content "$LOG_CONTENT" \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_url "$GITHUB_RUN_URL" \
            '{type: $type, content: $content, metadata: {run_id: $run_id, run_url: $run_url, workflow_type: "prd_implement"}}' \
            > .scratch/full-log-payload.json

          curl -sf -X POST "${CHIPP_ISSUES_API_URL}/api/issues/${INPUT_ISSUE_ID}/activity" \
            -H "Authorization: Bearer ${CHIPP_ISSUES_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @.scratch/full-log-payload.json || echo "Warning: Failed to upload full log (non-fatal)"

          echo "Full log uploaded ($(( FULL_SIZE / 1024 ))KB)"

      - name: Report failure
        if: failure() && steps.check-blocker.outputs.blocked != 'true' && env.CHIPP_ISSUES_API_URL != '' && env.CHIPP_ISSUES_API_KEY != ''
        run: |
          ERROR_TAIL=""
          if [ -f .scratch/claude-output.log ]; then
            ERROR_TAIL=$(tail -20 .scratch/claude-output.log)
          fi

          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          FAILURE_PAYLOAD=$(jq -n \
            --arg type "implementation_failed" \
            --arg content "PRD implementation workflow failed." \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg run_url "$GITHUB_RUN_URL" \
            --arg error_tail "$ERROR_TAIL" \
            '{type: $type, content: $content, metadata: {run_id: $run_id, run_url: $run_url, error_tail: $error_tail}}')

          curl -sf -X POST "${CHIPP_ISSUES_API_URL}/api/issues/${INPUT_ISSUE_ID}/activity" \
            -H "Authorization: Bearer ${CHIPP_ISSUES_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$FAILURE_PAYLOAD" || true

          STATUS_PAYLOAD=$(jq -n \
            --arg spawn_status "failed" \
            --arg spawn_completed_at "$TIMESTAMP" \
            --arg agent_status "idle" \
            '{spawn_status: $spawn_status, spawn_completed_at: $spawn_completed_at, agent_status: $agent_status}')

          curl -sf -X PATCH "${CHIPP_ISSUES_API_URL}/api/issues/${INPUT_ISSUE_ID}" \
            -H "Authorization: Bearer ${CHIPP_ISSUES_API_KEY}" \
            -H "Content-Type: application/json" \
            -d "$STATUS_PAYLOAD" || true
